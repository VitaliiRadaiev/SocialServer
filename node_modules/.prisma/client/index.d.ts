
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UserModel
 * 
 */
export type UserModel = $Result.DefaultSelection<Prisma.$UserModelPayload>
/**
 * Model UserPasswordModel
 * 
 */
export type UserPasswordModel = $Result.DefaultSelection<Prisma.$UserPasswordModelPayload>
/**
 * Model ProfileModel
 * 
 */
export type ProfileModel = $Result.DefaultSelection<Prisma.$ProfileModelPayload>
/**
 * Model ContactsModel
 * 
 */
export type ContactsModel = $Result.DefaultSelection<Prisma.$ContactsModelPayload>
/**
 * Model PhotosModel
 * 
 */
export type PhotosModel = $Result.DefaultSelection<Prisma.$PhotosModelPayload>
/**
 * Model DialogModel
 * 
 */
export type DialogModel = $Result.DefaultSelection<Prisma.$DialogModelPayload>
/**
 * Model MessageModel
 * 
 */
export type MessageModel = $Result.DefaultSelection<Prisma.$MessageModelPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UserModels
 * const userModels = await prisma.userModel.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UserModels
   * const userModels = await prisma.userModel.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.userModel`: Exposes CRUD operations for the **UserModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserModels
    * const userModels = await prisma.userModel.findMany()
    * ```
    */
  get userModel(): Prisma.UserModelDelegate<ExtArgs>;

  /**
   * `prisma.userPasswordModel`: Exposes CRUD operations for the **UserPasswordModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPasswordModels
    * const userPasswordModels = await prisma.userPasswordModel.findMany()
    * ```
    */
  get userPasswordModel(): Prisma.UserPasswordModelDelegate<ExtArgs>;

  /**
   * `prisma.profileModel`: Exposes CRUD operations for the **ProfileModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileModels
    * const profileModels = await prisma.profileModel.findMany()
    * ```
    */
  get profileModel(): Prisma.ProfileModelDelegate<ExtArgs>;

  /**
   * `prisma.contactsModel`: Exposes CRUD operations for the **ContactsModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactsModels
    * const contactsModels = await prisma.contactsModel.findMany()
    * ```
    */
  get contactsModel(): Prisma.ContactsModelDelegate<ExtArgs>;

  /**
   * `prisma.photosModel`: Exposes CRUD operations for the **PhotosModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhotosModels
    * const photosModels = await prisma.photosModel.findMany()
    * ```
    */
  get photosModel(): Prisma.PhotosModelDelegate<ExtArgs>;

  /**
   * `prisma.dialogModel`: Exposes CRUD operations for the **DialogModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DialogModels
    * const dialogModels = await prisma.dialogModel.findMany()
    * ```
    */
  get dialogModel(): Prisma.DialogModelDelegate<ExtArgs>;

  /**
   * `prisma.messageModel`: Exposes CRUD operations for the **MessageModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageModels
    * const messageModels = await prisma.messageModel.findMany()
    * ```
    */
  get messageModel(): Prisma.MessageModelDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.4.1
   * Query Engine version: 2f302df92bd8945e20ad4595a73def5b96afa54f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UserModel: 'UserModel',
    UserPasswordModel: 'UserPasswordModel',
    ProfileModel: 'ProfileModel',
    ContactsModel: 'ContactsModel',
    PhotosModel: 'PhotosModel',
    DialogModel: 'DialogModel',
    MessageModel: 'MessageModel'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'userModel' | 'userPasswordModel' | 'profileModel' | 'contactsModel' | 'photosModel' | 'dialogModel' | 'messageModel'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      UserModel: {
        payload: Prisma.$UserModelPayload<ExtArgs>
        fields: Prisma.UserModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserModelPayload>
          }
          findFirst: {
            args: Prisma.UserModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserModelPayload>
          }
          findMany: {
            args: Prisma.UserModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserModelPayload>[]
          }
          create: {
            args: Prisma.UserModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserModelPayload>
          }
          delete: {
            args: Prisma.UserModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserModelPayload>
          }
          update: {
            args: Prisma.UserModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserModelPayload>
          }
          deleteMany: {
            args: Prisma.UserModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserModelPayload>
          }
          aggregate: {
            args: Prisma.UserModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserModel>
          }
          groupBy: {
            args: Prisma.UserModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserModelCountArgs<ExtArgs>,
            result: $Utils.Optional<UserModelCountAggregateOutputType> | number
          }
        }
      }
      UserPasswordModel: {
        payload: Prisma.$UserPasswordModelPayload<ExtArgs>
        fields: Prisma.UserPasswordModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPasswordModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPasswordModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPasswordModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPasswordModelPayload>
          }
          findFirst: {
            args: Prisma.UserPasswordModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPasswordModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPasswordModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPasswordModelPayload>
          }
          findMany: {
            args: Prisma.UserPasswordModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPasswordModelPayload>[]
          }
          create: {
            args: Prisma.UserPasswordModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPasswordModelPayload>
          }
          delete: {
            args: Prisma.UserPasswordModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPasswordModelPayload>
          }
          update: {
            args: Prisma.UserPasswordModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPasswordModelPayload>
          }
          deleteMany: {
            args: Prisma.UserPasswordModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserPasswordModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserPasswordModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPasswordModelPayload>
          }
          aggregate: {
            args: Prisma.UserPasswordModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserPasswordModel>
          }
          groupBy: {
            args: Prisma.UserPasswordModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserPasswordModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPasswordModelCountArgs<ExtArgs>,
            result: $Utils.Optional<UserPasswordModelCountAggregateOutputType> | number
          }
        }
      }
      ProfileModel: {
        payload: Prisma.$ProfileModelPayload<ExtArgs>
        fields: Prisma.ProfileModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfileModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfileModelPayload>
          }
          findFirst: {
            args: Prisma.ProfileModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfileModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfileModelPayload>
          }
          findMany: {
            args: Prisma.ProfileModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfileModelPayload>[]
          }
          create: {
            args: Prisma.ProfileModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfileModelPayload>
          }
          delete: {
            args: Prisma.ProfileModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfileModelPayload>
          }
          update: {
            args: Prisma.ProfileModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfileModelPayload>
          }
          deleteMany: {
            args: Prisma.ProfileModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProfileModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfileModelPayload>
          }
          aggregate: {
            args: Prisma.ProfileModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProfileModel>
          }
          groupBy: {
            args: Prisma.ProfileModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProfileModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileModelCountArgs<ExtArgs>,
            result: $Utils.Optional<ProfileModelCountAggregateOutputType> | number
          }
        }
      }
      ContactsModel: {
        payload: Prisma.$ContactsModelPayload<ExtArgs>
        fields: Prisma.ContactsModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactsModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactsModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsModelPayload>
          }
          findFirst: {
            args: Prisma.ContactsModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactsModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsModelPayload>
          }
          findMany: {
            args: Prisma.ContactsModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsModelPayload>[]
          }
          create: {
            args: Prisma.ContactsModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsModelPayload>
          }
          delete: {
            args: Prisma.ContactsModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsModelPayload>
          }
          update: {
            args: Prisma.ContactsModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsModelPayload>
          }
          deleteMany: {
            args: Prisma.ContactsModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContactsModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContactsModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsModelPayload>
          }
          aggregate: {
            args: Prisma.ContactsModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContactsModel>
          }
          groupBy: {
            args: Prisma.ContactsModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContactsModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactsModelCountArgs<ExtArgs>,
            result: $Utils.Optional<ContactsModelCountAggregateOutputType> | number
          }
        }
      }
      PhotosModel: {
        payload: Prisma.$PhotosModelPayload<ExtArgs>
        fields: Prisma.PhotosModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhotosModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotosModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhotosModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotosModelPayload>
          }
          findFirst: {
            args: Prisma.PhotosModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotosModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhotosModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotosModelPayload>
          }
          findMany: {
            args: Prisma.PhotosModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotosModelPayload>[]
          }
          create: {
            args: Prisma.PhotosModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotosModelPayload>
          }
          delete: {
            args: Prisma.PhotosModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotosModelPayload>
          }
          update: {
            args: Prisma.PhotosModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotosModelPayload>
          }
          deleteMany: {
            args: Prisma.PhotosModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PhotosModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PhotosModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotosModelPayload>
          }
          aggregate: {
            args: Prisma.PhotosModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePhotosModel>
          }
          groupBy: {
            args: Prisma.PhotosModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PhotosModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhotosModelCountArgs<ExtArgs>,
            result: $Utils.Optional<PhotosModelCountAggregateOutputType> | number
          }
        }
      }
      DialogModel: {
        payload: Prisma.$DialogModelPayload<ExtArgs>
        fields: Prisma.DialogModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DialogModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DialogModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DialogModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DialogModelPayload>
          }
          findFirst: {
            args: Prisma.DialogModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DialogModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DialogModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DialogModelPayload>
          }
          findMany: {
            args: Prisma.DialogModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DialogModelPayload>[]
          }
          create: {
            args: Prisma.DialogModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DialogModelPayload>
          }
          delete: {
            args: Prisma.DialogModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DialogModelPayload>
          }
          update: {
            args: Prisma.DialogModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DialogModelPayload>
          }
          deleteMany: {
            args: Prisma.DialogModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DialogModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DialogModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DialogModelPayload>
          }
          aggregate: {
            args: Prisma.DialogModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDialogModel>
          }
          groupBy: {
            args: Prisma.DialogModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DialogModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.DialogModelCountArgs<ExtArgs>,
            result: $Utils.Optional<DialogModelCountAggregateOutputType> | number
          }
        }
      }
      MessageModel: {
        payload: Prisma.$MessageModelPayload<ExtArgs>
        fields: Prisma.MessageModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageModelPayload>
          }
          findFirst: {
            args: Prisma.MessageModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageModelPayload>
          }
          findMany: {
            args: Prisma.MessageModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageModelPayload>[]
          }
          create: {
            args: Prisma.MessageModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageModelPayload>
          }
          delete: {
            args: Prisma.MessageModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageModelPayload>
          }
          update: {
            args: Prisma.MessageModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageModelPayload>
          }
          deleteMany: {
            args: Prisma.MessageModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessageModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessageModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageModelPayload>
          }
          aggregate: {
            args: Prisma.MessageModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessageModel>
          }
          groupBy: {
            args: Prisma.MessageModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessageModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageModelCountArgs<ExtArgs>,
            result: $Utils.Optional<MessageModelCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DialogModelCountOutputType
   */

  export type DialogModelCountOutputType = {
    messages: number
  }

  export type DialogModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | DialogModelCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes

  /**
   * DialogModelCountOutputType without action
   */
  export type DialogModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DialogModelCountOutputType
     */
    select?: DialogModelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DialogModelCountOutputType without action
   */
  export type DialogModelCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageModelWhereInput
  }



  /**
   * Models
   */

  /**
   * Model UserModel
   */

  export type AggregateUserModel = {
    _count: UserModelCountAggregateOutputType | null
    _avg: UserModelAvgAggregateOutputType | null
    _sum: UserModelSumAggregateOutputType | null
    _min: UserModelMinAggregateOutputType | null
    _max: UserModelMaxAggregateOutputType | null
  }

  export type UserModelAvgAggregateOutputType = {
    id: number | null
  }

  export type UserModelSumAggregateOutputType = {
    id: number | null
  }

  export type UserModelMinAggregateOutputType = {
    id: number | null
    email: string | null
    login: string | null
    followed: string | null
    dialogs: string | null
  }

  export type UserModelMaxAggregateOutputType = {
    id: number | null
    email: string | null
    login: string | null
    followed: string | null
    dialogs: string | null
  }

  export type UserModelCountAggregateOutputType = {
    id: number
    email: number
    login: number
    followed: number
    dialogs: number
    _all: number
  }


  export type UserModelAvgAggregateInputType = {
    id?: true
  }

  export type UserModelSumAggregateInputType = {
    id?: true
  }

  export type UserModelMinAggregateInputType = {
    id?: true
    email?: true
    login?: true
    followed?: true
    dialogs?: true
  }

  export type UserModelMaxAggregateInputType = {
    id?: true
    email?: true
    login?: true
    followed?: true
    dialogs?: true
  }

  export type UserModelCountAggregateInputType = {
    id?: true
    email?: true
    login?: true
    followed?: true
    dialogs?: true
    _all?: true
  }

  export type UserModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserModel to aggregate.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: UserModelOrderByWithRelationInput | UserModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserModels
    **/
    _count?: true | UserModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserModelMaxAggregateInputType
  }

  export type GetUserModelAggregateType<T extends UserModelAggregateArgs> = {
        [P in keyof T & keyof AggregateUserModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserModel[P]>
      : GetScalarType<T[P], AggregateUserModel[P]>
  }




  export type UserModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserModelWhereInput
    orderBy?: UserModelOrderByWithAggregationInput | UserModelOrderByWithAggregationInput[]
    by: UserModelScalarFieldEnum[] | UserModelScalarFieldEnum
    having?: UserModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserModelCountAggregateInputType | true
    _avg?: UserModelAvgAggregateInputType
    _sum?: UserModelSumAggregateInputType
    _min?: UserModelMinAggregateInputType
    _max?: UserModelMaxAggregateInputType
  }

  export type UserModelGroupByOutputType = {
    id: number
    email: string
    login: string
    followed: string | null
    dialogs: string | null
    _count: UserModelCountAggregateOutputType | null
    _avg: UserModelAvgAggregateOutputType | null
    _sum: UserModelSumAggregateOutputType | null
    _min: UserModelMinAggregateOutputType | null
    _max: UserModelMaxAggregateOutputType | null
  }

  type GetUserModelGroupByPayload<T extends UserModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserModelGroupByOutputType[P]>
            : GetScalarType<T[P], UserModelGroupByOutputType[P]>
        }
      >
    >


  export type UserModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    login?: boolean
    followed?: boolean
    dialogs?: boolean
    password?: boolean | UserModel$passwordArgs<ExtArgs>
    profile?: boolean | UserModel$profileArgs<ExtArgs>
  }, ExtArgs["result"]["userModel"]>

  export type UserModelSelectScalar = {
    id?: boolean
    email?: boolean
    login?: boolean
    followed?: boolean
    dialogs?: boolean
  }

  export type UserModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | UserModel$passwordArgs<ExtArgs>
    profile?: boolean | UserModel$profileArgs<ExtArgs>
  }


  export type $UserModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserModel"
    objects: {
      password: Prisma.$UserPasswordModelPayload<ExtArgs> | null
      profile: Prisma.$ProfileModelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      login: string
      followed: string | null
      dialogs: string | null
    }, ExtArgs["result"]["userModel"]>
    composites: {}
  }


  type UserModelGetPayload<S extends boolean | null | undefined | UserModelDefaultArgs> = $Result.GetResult<Prisma.$UserModelPayload, S>

  type UserModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserModelFindManyArgs, 'select' | 'include'> & {
      select?: UserModelCountAggregateInputType | true
    }

  export interface UserModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserModel'], meta: { name: 'UserModel' } }
    /**
     * Find zero or one UserModel that matches the filter.
     * @param {UserModelFindUniqueArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserModelFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserModelFindUniqueArgs<ExtArgs>>
    ): Prisma__UserModelClient<$Result.GetResult<Prisma.$UserModelPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserModelFindUniqueOrThrowArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserModelClient<$Result.GetResult<Prisma.$UserModelPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelFindFirstArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserModelFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserModelFindFirstArgs<ExtArgs>>
    ): Prisma__UserModelClient<$Result.GetResult<Prisma.$UserModelPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelFindFirstOrThrowArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserModelClient<$Result.GetResult<Prisma.$UserModelPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserModels
     * const userModels = await prisma.userModel.findMany()
     * 
     * // Get first 10 UserModels
     * const userModels = await prisma.userModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userModelWithIdOnly = await prisma.userModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserModelPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserModel.
     * @param {UserModelCreateArgs} args - Arguments to create a UserModel.
     * @example
     * // Create one UserModel
     * const UserModel = await prisma.userModel.create({
     *   data: {
     *     // ... data to create a UserModel
     *   }
     * })
     * 
    **/
    create<T extends UserModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserModelCreateArgs<ExtArgs>>
    ): Prisma__UserModelClient<$Result.GetResult<Prisma.$UserModelPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a UserModel.
     * @param {UserModelDeleteArgs} args - Arguments to delete one UserModel.
     * @example
     * // Delete one UserModel
     * const UserModel = await prisma.userModel.delete({
     *   where: {
     *     // ... filter to delete one UserModel
     *   }
     * })
     * 
    **/
    delete<T extends UserModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserModelDeleteArgs<ExtArgs>>
    ): Prisma__UserModelClient<$Result.GetResult<Prisma.$UserModelPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserModel.
     * @param {UserModelUpdateArgs} args - Arguments to update one UserModel.
     * @example
     * // Update one UserModel
     * const userModel = await prisma.userModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserModelUpdateArgs<ExtArgs>>
    ): Prisma__UserModelClient<$Result.GetResult<Prisma.$UserModelPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserModels.
     * @param {UserModelDeleteManyArgs} args - Arguments to filter UserModels to delete.
     * @example
     * // Delete a few UserModels
     * const { count } = await prisma.userModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserModels
     * const userModel = await prisma.userModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserModel.
     * @param {UserModelUpsertArgs} args - Arguments to update or create a UserModel.
     * @example
     * // Update or create a UserModel
     * const userModel = await prisma.userModel.upsert({
     *   create: {
     *     // ... data to create a UserModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserModel we want to update
     *   }
     * })
    **/
    upsert<T extends UserModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserModelUpsertArgs<ExtArgs>>
    ): Prisma__UserModelClient<$Result.GetResult<Prisma.$UserModelPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelCountArgs} args - Arguments to filter UserModels to count.
     * @example
     * // Count the number of UserModels
     * const count = await prisma.userModel.count({
     *   where: {
     *     // ... the filter for the UserModels we want to count
     *   }
     * })
    **/
    count<T extends UserModelCountArgs>(
      args?: Subset<T, UserModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserModelAggregateArgs>(args: Subset<T, UserModelAggregateArgs>): Prisma.PrismaPromise<GetUserModelAggregateType<T>>

    /**
     * Group by UserModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserModelGroupByArgs['orderBy'] }
        : { orderBy?: UserModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserModel model
   */
  readonly fields: UserModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    password<T extends UserModel$passwordArgs<ExtArgs> = {}>(args?: Subset<T, UserModel$passwordArgs<ExtArgs>>): Prisma__UserPasswordModelClient<$Result.GetResult<Prisma.$UserPasswordModelPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    profile<T extends UserModel$profileArgs<ExtArgs> = {}>(args?: Subset<T, UserModel$profileArgs<ExtArgs>>): Prisma__ProfileModelClient<$Result.GetResult<Prisma.$ProfileModelPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserModel model
   */ 
  interface UserModelFieldRefs {
    readonly id: FieldRef<"UserModel", 'Int'>
    readonly email: FieldRef<"UserModel", 'String'>
    readonly login: FieldRef<"UserModel", 'String'>
    readonly followed: FieldRef<"UserModel", 'String'>
    readonly dialogs: FieldRef<"UserModel", 'String'>
  }
    

  // Custom InputTypes

  /**
   * UserModel findUnique
   */
  export type UserModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * Filter, which UserModel to fetch.
     */
    where: UserModelWhereUniqueInput
  }


  /**
   * UserModel findUniqueOrThrow
   */
  export type UserModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * Filter, which UserModel to fetch.
     */
    where: UserModelWhereUniqueInput
  }


  /**
   * UserModel findFirst
   */
  export type UserModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * Filter, which UserModel to fetch.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: UserModelOrderByWithRelationInput | UserModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserModels.
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserModels.
     */
    distinct?: UserModelScalarFieldEnum | UserModelScalarFieldEnum[]
  }


  /**
   * UserModel findFirstOrThrow
   */
  export type UserModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * Filter, which UserModel to fetch.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: UserModelOrderByWithRelationInput | UserModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserModels.
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserModels.
     */
    distinct?: UserModelScalarFieldEnum | UserModelScalarFieldEnum[]
  }


  /**
   * UserModel findMany
   */
  export type UserModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * Filter, which UserModels to fetch.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: UserModelOrderByWithRelationInput | UserModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserModels.
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    distinct?: UserModelScalarFieldEnum | UserModelScalarFieldEnum[]
  }


  /**
   * UserModel create
   */
  export type UserModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * The data needed to create a UserModel.
     */
    data: XOR<UserModelCreateInput, UserModelUncheckedCreateInput>
  }


  /**
   * UserModel update
   */
  export type UserModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * The data needed to update a UserModel.
     */
    data: XOR<UserModelUpdateInput, UserModelUncheckedUpdateInput>
    /**
     * Choose, which UserModel to update.
     */
    where: UserModelWhereUniqueInput
  }


  /**
   * UserModel updateMany
   */
  export type UserModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserModels.
     */
    data: XOR<UserModelUpdateManyMutationInput, UserModelUncheckedUpdateManyInput>
    /**
     * Filter which UserModels to update
     */
    where?: UserModelWhereInput
  }


  /**
   * UserModel upsert
   */
  export type UserModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * The filter to search for the UserModel to update in case it exists.
     */
    where: UserModelWhereUniqueInput
    /**
     * In case the UserModel found by the `where` argument doesn't exist, create a new UserModel with this data.
     */
    create: XOR<UserModelCreateInput, UserModelUncheckedCreateInput>
    /**
     * In case the UserModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserModelUpdateInput, UserModelUncheckedUpdateInput>
  }


  /**
   * UserModel delete
   */
  export type UserModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * Filter which UserModel to delete.
     */
    where: UserModelWhereUniqueInput
  }


  /**
   * UserModel deleteMany
   */
  export type UserModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserModels to delete
     */
    where?: UserModelWhereInput
  }


  /**
   * UserModel.password
   */
  export type UserModel$passwordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPasswordModel
     */
    select?: UserPasswordModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordModelInclude<ExtArgs> | null
    where?: UserPasswordModelWhereInput
  }


  /**
   * UserModel.profile
   */
  export type UserModel$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileModel
     */
    select?: ProfileModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileModelInclude<ExtArgs> | null
    where?: ProfileModelWhereInput
  }


  /**
   * UserModel without action
   */
  export type UserModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
  }



  /**
   * Model UserPasswordModel
   */

  export type AggregateUserPasswordModel = {
    _count: UserPasswordModelCountAggregateOutputType | null
    _avg: UserPasswordModelAvgAggregateOutputType | null
    _sum: UserPasswordModelSumAggregateOutputType | null
    _min: UserPasswordModelMinAggregateOutputType | null
    _max: UserPasswordModelMaxAggregateOutputType | null
  }

  export type UserPasswordModelAvgAggregateOutputType = {
    userId: number | null
  }

  export type UserPasswordModelSumAggregateOutputType = {
    userId: number | null
  }

  export type UserPasswordModelMinAggregateOutputType = {
    userId: number | null
    password: string | null
  }

  export type UserPasswordModelMaxAggregateOutputType = {
    userId: number | null
    password: string | null
  }

  export type UserPasswordModelCountAggregateOutputType = {
    userId: number
    password: number
    _all: number
  }


  export type UserPasswordModelAvgAggregateInputType = {
    userId?: true
  }

  export type UserPasswordModelSumAggregateInputType = {
    userId?: true
  }

  export type UserPasswordModelMinAggregateInputType = {
    userId?: true
    password?: true
  }

  export type UserPasswordModelMaxAggregateInputType = {
    userId?: true
    password?: true
  }

  export type UserPasswordModelCountAggregateInputType = {
    userId?: true
    password?: true
    _all?: true
  }

  export type UserPasswordModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPasswordModel to aggregate.
     */
    where?: UserPasswordModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPasswordModels to fetch.
     */
    orderBy?: UserPasswordModelOrderByWithRelationInput | UserPasswordModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPasswordModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPasswordModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPasswordModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPasswordModels
    **/
    _count?: true | UserPasswordModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPasswordModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPasswordModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPasswordModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPasswordModelMaxAggregateInputType
  }

  export type GetUserPasswordModelAggregateType<T extends UserPasswordModelAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPasswordModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPasswordModel[P]>
      : GetScalarType<T[P], AggregateUserPasswordModel[P]>
  }




  export type UserPasswordModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPasswordModelWhereInput
    orderBy?: UserPasswordModelOrderByWithAggregationInput | UserPasswordModelOrderByWithAggregationInput[]
    by: UserPasswordModelScalarFieldEnum[] | UserPasswordModelScalarFieldEnum
    having?: UserPasswordModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPasswordModelCountAggregateInputType | true
    _avg?: UserPasswordModelAvgAggregateInputType
    _sum?: UserPasswordModelSumAggregateInputType
    _min?: UserPasswordModelMinAggregateInputType
    _max?: UserPasswordModelMaxAggregateInputType
  }

  export type UserPasswordModelGroupByOutputType = {
    userId: number
    password: string
    _count: UserPasswordModelCountAggregateOutputType | null
    _avg: UserPasswordModelAvgAggregateOutputType | null
    _sum: UserPasswordModelSumAggregateOutputType | null
    _min: UserPasswordModelMinAggregateOutputType | null
    _max: UserPasswordModelMaxAggregateOutputType | null
  }

  type GetUserPasswordModelGroupByPayload<T extends UserPasswordModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPasswordModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPasswordModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPasswordModelGroupByOutputType[P]>
            : GetScalarType<T[P], UserPasswordModelGroupByOutputType[P]>
        }
      >
    >


  export type UserPasswordModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    password?: boolean
    user?: boolean | UserModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPasswordModel"]>

  export type UserPasswordModelSelectScalar = {
    userId?: boolean
    password?: boolean
  }

  export type UserPasswordModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserModelDefaultArgs<ExtArgs>
  }


  export type $UserPasswordModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPasswordModel"
    objects: {
      user: Prisma.$UserModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      password: string
    }, ExtArgs["result"]["userPasswordModel"]>
    composites: {}
  }


  type UserPasswordModelGetPayload<S extends boolean | null | undefined | UserPasswordModelDefaultArgs> = $Result.GetResult<Prisma.$UserPasswordModelPayload, S>

  type UserPasswordModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserPasswordModelFindManyArgs, 'select' | 'include'> & {
      select?: UserPasswordModelCountAggregateInputType | true
    }

  export interface UserPasswordModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPasswordModel'], meta: { name: 'UserPasswordModel' } }
    /**
     * Find zero or one UserPasswordModel that matches the filter.
     * @param {UserPasswordModelFindUniqueArgs} args - Arguments to find a UserPasswordModel
     * @example
     * // Get one UserPasswordModel
     * const userPasswordModel = await prisma.userPasswordModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserPasswordModelFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserPasswordModelFindUniqueArgs<ExtArgs>>
    ): Prisma__UserPasswordModelClient<$Result.GetResult<Prisma.$UserPasswordModelPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserPasswordModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserPasswordModelFindUniqueOrThrowArgs} args - Arguments to find a UserPasswordModel
     * @example
     * // Get one UserPasswordModel
     * const userPasswordModel = await prisma.userPasswordModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserPasswordModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPasswordModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserPasswordModelClient<$Result.GetResult<Prisma.$UserPasswordModelPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserPasswordModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordModelFindFirstArgs} args - Arguments to find a UserPasswordModel
     * @example
     * // Get one UserPasswordModel
     * const userPasswordModel = await prisma.userPasswordModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserPasswordModelFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPasswordModelFindFirstArgs<ExtArgs>>
    ): Prisma__UserPasswordModelClient<$Result.GetResult<Prisma.$UserPasswordModelPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserPasswordModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordModelFindFirstOrThrowArgs} args - Arguments to find a UserPasswordModel
     * @example
     * // Get one UserPasswordModel
     * const userPasswordModel = await prisma.userPasswordModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserPasswordModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPasswordModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserPasswordModelClient<$Result.GetResult<Prisma.$UserPasswordModelPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserPasswordModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPasswordModels
     * const userPasswordModels = await prisma.userPasswordModel.findMany()
     * 
     * // Get first 10 UserPasswordModels
     * const userPasswordModels = await prisma.userPasswordModel.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userPasswordModelWithUserIdOnly = await prisma.userPasswordModel.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserPasswordModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPasswordModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPasswordModelPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserPasswordModel.
     * @param {UserPasswordModelCreateArgs} args - Arguments to create a UserPasswordModel.
     * @example
     * // Create one UserPasswordModel
     * const UserPasswordModel = await prisma.userPasswordModel.create({
     *   data: {
     *     // ... data to create a UserPasswordModel
     *   }
     * })
     * 
    **/
    create<T extends UserPasswordModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserPasswordModelCreateArgs<ExtArgs>>
    ): Prisma__UserPasswordModelClient<$Result.GetResult<Prisma.$UserPasswordModelPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a UserPasswordModel.
     * @param {UserPasswordModelDeleteArgs} args - Arguments to delete one UserPasswordModel.
     * @example
     * // Delete one UserPasswordModel
     * const UserPasswordModel = await prisma.userPasswordModel.delete({
     *   where: {
     *     // ... filter to delete one UserPasswordModel
     *   }
     * })
     * 
    **/
    delete<T extends UserPasswordModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserPasswordModelDeleteArgs<ExtArgs>>
    ): Prisma__UserPasswordModelClient<$Result.GetResult<Prisma.$UserPasswordModelPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserPasswordModel.
     * @param {UserPasswordModelUpdateArgs} args - Arguments to update one UserPasswordModel.
     * @example
     * // Update one UserPasswordModel
     * const userPasswordModel = await prisma.userPasswordModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserPasswordModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserPasswordModelUpdateArgs<ExtArgs>>
    ): Prisma__UserPasswordModelClient<$Result.GetResult<Prisma.$UserPasswordModelPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserPasswordModels.
     * @param {UserPasswordModelDeleteManyArgs} args - Arguments to filter UserPasswordModels to delete.
     * @example
     * // Delete a few UserPasswordModels
     * const { count } = await prisma.userPasswordModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserPasswordModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPasswordModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPasswordModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPasswordModels
     * const userPasswordModel = await prisma.userPasswordModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserPasswordModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserPasswordModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPasswordModel.
     * @param {UserPasswordModelUpsertArgs} args - Arguments to update or create a UserPasswordModel.
     * @example
     * // Update or create a UserPasswordModel
     * const userPasswordModel = await prisma.userPasswordModel.upsert({
     *   create: {
     *     // ... data to create a UserPasswordModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPasswordModel we want to update
     *   }
     * })
    **/
    upsert<T extends UserPasswordModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserPasswordModelUpsertArgs<ExtArgs>>
    ): Prisma__UserPasswordModelClient<$Result.GetResult<Prisma.$UserPasswordModelPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserPasswordModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordModelCountArgs} args - Arguments to filter UserPasswordModels to count.
     * @example
     * // Count the number of UserPasswordModels
     * const count = await prisma.userPasswordModel.count({
     *   where: {
     *     // ... the filter for the UserPasswordModels we want to count
     *   }
     * })
    **/
    count<T extends UserPasswordModelCountArgs>(
      args?: Subset<T, UserPasswordModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPasswordModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPasswordModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPasswordModelAggregateArgs>(args: Subset<T, UserPasswordModelAggregateArgs>): Prisma.PrismaPromise<GetUserPasswordModelAggregateType<T>>

    /**
     * Group by UserPasswordModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPasswordModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPasswordModelGroupByArgs['orderBy'] }
        : { orderBy?: UserPasswordModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPasswordModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPasswordModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPasswordModel model
   */
  readonly fields: UserPasswordModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPasswordModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPasswordModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserModelDefaultArgs<ExtArgs>>): Prisma__UserModelClient<$Result.GetResult<Prisma.$UserModelPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserPasswordModel model
   */ 
  interface UserPasswordModelFieldRefs {
    readonly userId: FieldRef<"UserPasswordModel", 'Int'>
    readonly password: FieldRef<"UserPasswordModel", 'String'>
  }
    

  // Custom InputTypes

  /**
   * UserPasswordModel findUnique
   */
  export type UserPasswordModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPasswordModel
     */
    select?: UserPasswordModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordModelInclude<ExtArgs> | null
    /**
     * Filter, which UserPasswordModel to fetch.
     */
    where: UserPasswordModelWhereUniqueInput
  }


  /**
   * UserPasswordModel findUniqueOrThrow
   */
  export type UserPasswordModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPasswordModel
     */
    select?: UserPasswordModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordModelInclude<ExtArgs> | null
    /**
     * Filter, which UserPasswordModel to fetch.
     */
    where: UserPasswordModelWhereUniqueInput
  }


  /**
   * UserPasswordModel findFirst
   */
  export type UserPasswordModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPasswordModel
     */
    select?: UserPasswordModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordModelInclude<ExtArgs> | null
    /**
     * Filter, which UserPasswordModel to fetch.
     */
    where?: UserPasswordModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPasswordModels to fetch.
     */
    orderBy?: UserPasswordModelOrderByWithRelationInput | UserPasswordModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPasswordModels.
     */
    cursor?: UserPasswordModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPasswordModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPasswordModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPasswordModels.
     */
    distinct?: UserPasswordModelScalarFieldEnum | UserPasswordModelScalarFieldEnum[]
  }


  /**
   * UserPasswordModel findFirstOrThrow
   */
  export type UserPasswordModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPasswordModel
     */
    select?: UserPasswordModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordModelInclude<ExtArgs> | null
    /**
     * Filter, which UserPasswordModel to fetch.
     */
    where?: UserPasswordModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPasswordModels to fetch.
     */
    orderBy?: UserPasswordModelOrderByWithRelationInput | UserPasswordModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPasswordModels.
     */
    cursor?: UserPasswordModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPasswordModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPasswordModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPasswordModels.
     */
    distinct?: UserPasswordModelScalarFieldEnum | UserPasswordModelScalarFieldEnum[]
  }


  /**
   * UserPasswordModel findMany
   */
  export type UserPasswordModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPasswordModel
     */
    select?: UserPasswordModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordModelInclude<ExtArgs> | null
    /**
     * Filter, which UserPasswordModels to fetch.
     */
    where?: UserPasswordModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPasswordModels to fetch.
     */
    orderBy?: UserPasswordModelOrderByWithRelationInput | UserPasswordModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPasswordModels.
     */
    cursor?: UserPasswordModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPasswordModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPasswordModels.
     */
    skip?: number
    distinct?: UserPasswordModelScalarFieldEnum | UserPasswordModelScalarFieldEnum[]
  }


  /**
   * UserPasswordModel create
   */
  export type UserPasswordModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPasswordModel
     */
    select?: UserPasswordModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordModelInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPasswordModel.
     */
    data: XOR<UserPasswordModelCreateInput, UserPasswordModelUncheckedCreateInput>
  }


  /**
   * UserPasswordModel update
   */
  export type UserPasswordModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPasswordModel
     */
    select?: UserPasswordModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordModelInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPasswordModel.
     */
    data: XOR<UserPasswordModelUpdateInput, UserPasswordModelUncheckedUpdateInput>
    /**
     * Choose, which UserPasswordModel to update.
     */
    where: UserPasswordModelWhereUniqueInput
  }


  /**
   * UserPasswordModel updateMany
   */
  export type UserPasswordModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPasswordModels.
     */
    data: XOR<UserPasswordModelUpdateManyMutationInput, UserPasswordModelUncheckedUpdateManyInput>
    /**
     * Filter which UserPasswordModels to update
     */
    where?: UserPasswordModelWhereInput
  }


  /**
   * UserPasswordModel upsert
   */
  export type UserPasswordModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPasswordModel
     */
    select?: UserPasswordModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordModelInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPasswordModel to update in case it exists.
     */
    where: UserPasswordModelWhereUniqueInput
    /**
     * In case the UserPasswordModel found by the `where` argument doesn't exist, create a new UserPasswordModel with this data.
     */
    create: XOR<UserPasswordModelCreateInput, UserPasswordModelUncheckedCreateInput>
    /**
     * In case the UserPasswordModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPasswordModelUpdateInput, UserPasswordModelUncheckedUpdateInput>
  }


  /**
   * UserPasswordModel delete
   */
  export type UserPasswordModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPasswordModel
     */
    select?: UserPasswordModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordModelInclude<ExtArgs> | null
    /**
     * Filter which UserPasswordModel to delete.
     */
    where: UserPasswordModelWhereUniqueInput
  }


  /**
   * UserPasswordModel deleteMany
   */
  export type UserPasswordModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPasswordModels to delete
     */
    where?: UserPasswordModelWhereInput
  }


  /**
   * UserPasswordModel without action
   */
  export type UserPasswordModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPasswordModel
     */
    select?: UserPasswordModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordModelInclude<ExtArgs> | null
  }



  /**
   * Model ProfileModel
   */

  export type AggregateProfileModel = {
    _count: ProfileModelCountAggregateOutputType | null
    _avg: ProfileModelAvgAggregateOutputType | null
    _sum: ProfileModelSumAggregateOutputType | null
    _min: ProfileModelMinAggregateOutputType | null
    _max: ProfileModelMaxAggregateOutputType | null
  }

  export type ProfileModelAvgAggregateOutputType = {
    userId: number | null
  }

  export type ProfileModelSumAggregateOutputType = {
    userId: number | null
  }

  export type ProfileModelMinAggregateOutputType = {
    userId: number | null
    lookingForAJob: boolean | null
    lookingForAJobDescription: string | null
    fullName: string | null
    status: string | null
  }

  export type ProfileModelMaxAggregateOutputType = {
    userId: number | null
    lookingForAJob: boolean | null
    lookingForAJobDescription: string | null
    fullName: string | null
    status: string | null
  }

  export type ProfileModelCountAggregateOutputType = {
    userId: number
    lookingForAJob: number
    lookingForAJobDescription: number
    fullName: number
    status: number
    _all: number
  }


  export type ProfileModelAvgAggregateInputType = {
    userId?: true
  }

  export type ProfileModelSumAggregateInputType = {
    userId?: true
  }

  export type ProfileModelMinAggregateInputType = {
    userId?: true
    lookingForAJob?: true
    lookingForAJobDescription?: true
    fullName?: true
    status?: true
  }

  export type ProfileModelMaxAggregateInputType = {
    userId?: true
    lookingForAJob?: true
    lookingForAJobDescription?: true
    fullName?: true
    status?: true
  }

  export type ProfileModelCountAggregateInputType = {
    userId?: true
    lookingForAJob?: true
    lookingForAJobDescription?: true
    fullName?: true
    status?: true
    _all?: true
  }

  export type ProfileModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileModel to aggregate.
     */
    where?: ProfileModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileModels to fetch.
     */
    orderBy?: ProfileModelOrderByWithRelationInput | ProfileModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileModels
    **/
    _count?: true | ProfileModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileModelMaxAggregateInputType
  }

  export type GetProfileModelAggregateType<T extends ProfileModelAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileModel[P]>
      : GetScalarType<T[P], AggregateProfileModel[P]>
  }




  export type ProfileModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileModelWhereInput
    orderBy?: ProfileModelOrderByWithAggregationInput | ProfileModelOrderByWithAggregationInput[]
    by: ProfileModelScalarFieldEnum[] | ProfileModelScalarFieldEnum
    having?: ProfileModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileModelCountAggregateInputType | true
    _avg?: ProfileModelAvgAggregateInputType
    _sum?: ProfileModelSumAggregateInputType
    _min?: ProfileModelMinAggregateInputType
    _max?: ProfileModelMaxAggregateInputType
  }

  export type ProfileModelGroupByOutputType = {
    userId: number
    lookingForAJob: boolean
    lookingForAJobDescription: string | null
    fullName: string | null
    status: string | null
    _count: ProfileModelCountAggregateOutputType | null
    _avg: ProfileModelAvgAggregateOutputType | null
    _sum: ProfileModelSumAggregateOutputType | null
    _min: ProfileModelMinAggregateOutputType | null
    _max: ProfileModelMaxAggregateOutputType | null
  }

  type GetProfileModelGroupByPayload<T extends ProfileModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileModelGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileModelGroupByOutputType[P]>
        }
      >
    >


  export type ProfileModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    lookingForAJob?: boolean
    lookingForAJobDescription?: boolean
    fullName?: boolean
    status?: boolean
    user?: boolean | UserModelDefaultArgs<ExtArgs>
    contacts?: boolean | ProfileModel$contactsArgs<ExtArgs>
    photos?: boolean | ProfileModel$photosArgs<ExtArgs>
  }, ExtArgs["result"]["profileModel"]>

  export type ProfileModelSelectScalar = {
    userId?: boolean
    lookingForAJob?: boolean
    lookingForAJobDescription?: boolean
    fullName?: boolean
    status?: boolean
  }

  export type ProfileModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserModelDefaultArgs<ExtArgs>
    contacts?: boolean | ProfileModel$contactsArgs<ExtArgs>
    photos?: boolean | ProfileModel$photosArgs<ExtArgs>
  }


  export type $ProfileModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileModel"
    objects: {
      user: Prisma.$UserModelPayload<ExtArgs>
      contacts: Prisma.$ContactsModelPayload<ExtArgs> | null
      photos: Prisma.$PhotosModelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      lookingForAJob: boolean
      lookingForAJobDescription: string | null
      fullName: string | null
      status: string | null
    }, ExtArgs["result"]["profileModel"]>
    composites: {}
  }


  type ProfileModelGetPayload<S extends boolean | null | undefined | ProfileModelDefaultArgs> = $Result.GetResult<Prisma.$ProfileModelPayload, S>

  type ProfileModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileModelFindManyArgs, 'select' | 'include'> & {
      select?: ProfileModelCountAggregateInputType | true
    }

  export interface ProfileModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileModel'], meta: { name: 'ProfileModel' } }
    /**
     * Find zero or one ProfileModel that matches the filter.
     * @param {ProfileModelFindUniqueArgs} args - Arguments to find a ProfileModel
     * @example
     * // Get one ProfileModel
     * const profileModel = await prisma.profileModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProfileModelFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileModelFindUniqueArgs<ExtArgs>>
    ): Prisma__ProfileModelClient<$Result.GetResult<Prisma.$ProfileModelPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ProfileModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProfileModelFindUniqueOrThrowArgs} args - Arguments to find a ProfileModel
     * @example
     * // Get one ProfileModel
     * const profileModel = await prisma.profileModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProfileModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProfileModelClient<$Result.GetResult<Prisma.$ProfileModelPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ProfileModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileModelFindFirstArgs} args - Arguments to find a ProfileModel
     * @example
     * // Get one ProfileModel
     * const profileModel = await prisma.profileModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProfileModelFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileModelFindFirstArgs<ExtArgs>>
    ): Prisma__ProfileModelClient<$Result.GetResult<Prisma.$ProfileModelPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ProfileModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileModelFindFirstOrThrowArgs} args - Arguments to find a ProfileModel
     * @example
     * // Get one ProfileModel
     * const profileModel = await prisma.profileModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProfileModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProfileModelClient<$Result.GetResult<Prisma.$ProfileModelPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ProfileModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileModels
     * const profileModels = await prisma.profileModel.findMany()
     * 
     * // Get first 10 ProfileModels
     * const profileModels = await prisma.profileModel.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const profileModelWithUserIdOnly = await prisma.profileModel.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends ProfileModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileModelPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ProfileModel.
     * @param {ProfileModelCreateArgs} args - Arguments to create a ProfileModel.
     * @example
     * // Create one ProfileModel
     * const ProfileModel = await prisma.profileModel.create({
     *   data: {
     *     // ... data to create a ProfileModel
     *   }
     * })
     * 
    **/
    create<T extends ProfileModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileModelCreateArgs<ExtArgs>>
    ): Prisma__ProfileModelClient<$Result.GetResult<Prisma.$ProfileModelPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a ProfileModel.
     * @param {ProfileModelDeleteArgs} args - Arguments to delete one ProfileModel.
     * @example
     * // Delete one ProfileModel
     * const ProfileModel = await prisma.profileModel.delete({
     *   where: {
     *     // ... filter to delete one ProfileModel
     *   }
     * })
     * 
    **/
    delete<T extends ProfileModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileModelDeleteArgs<ExtArgs>>
    ): Prisma__ProfileModelClient<$Result.GetResult<Prisma.$ProfileModelPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ProfileModel.
     * @param {ProfileModelUpdateArgs} args - Arguments to update one ProfileModel.
     * @example
     * // Update one ProfileModel
     * const profileModel = await prisma.profileModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProfileModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileModelUpdateArgs<ExtArgs>>
    ): Prisma__ProfileModelClient<$Result.GetResult<Prisma.$ProfileModelPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ProfileModels.
     * @param {ProfileModelDeleteManyArgs} args - Arguments to filter ProfileModels to delete.
     * @example
     * // Delete a few ProfileModels
     * const { count } = await prisma.profileModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProfileModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileModels
     * const profileModel = await prisma.profileModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProfileModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileModel.
     * @param {ProfileModelUpsertArgs} args - Arguments to update or create a ProfileModel.
     * @example
     * // Update or create a ProfileModel
     * const profileModel = await prisma.profileModel.upsert({
     *   create: {
     *     // ... data to create a ProfileModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileModel we want to update
     *   }
     * })
    **/
    upsert<T extends ProfileModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileModelUpsertArgs<ExtArgs>>
    ): Prisma__ProfileModelClient<$Result.GetResult<Prisma.$ProfileModelPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ProfileModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileModelCountArgs} args - Arguments to filter ProfileModels to count.
     * @example
     * // Count the number of ProfileModels
     * const count = await prisma.profileModel.count({
     *   where: {
     *     // ... the filter for the ProfileModels we want to count
     *   }
     * })
    **/
    count<T extends ProfileModelCountArgs>(
      args?: Subset<T, ProfileModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileModelAggregateArgs>(args: Subset<T, ProfileModelAggregateArgs>): Prisma.PrismaPromise<GetProfileModelAggregateType<T>>

    /**
     * Group by ProfileModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileModelGroupByArgs['orderBy'] }
        : { orderBy?: ProfileModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileModel model
   */
  readonly fields: ProfileModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserModelDefaultArgs<ExtArgs>>): Prisma__UserModelClient<$Result.GetResult<Prisma.$UserModelPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    contacts<T extends ProfileModel$contactsArgs<ExtArgs> = {}>(args?: Subset<T, ProfileModel$contactsArgs<ExtArgs>>): Prisma__ContactsModelClient<$Result.GetResult<Prisma.$ContactsModelPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    photos<T extends ProfileModel$photosArgs<ExtArgs> = {}>(args?: Subset<T, ProfileModel$photosArgs<ExtArgs>>): Prisma__PhotosModelClient<$Result.GetResult<Prisma.$PhotosModelPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ProfileModel model
   */ 
  interface ProfileModelFieldRefs {
    readonly userId: FieldRef<"ProfileModel", 'Int'>
    readonly lookingForAJob: FieldRef<"ProfileModel", 'Boolean'>
    readonly lookingForAJobDescription: FieldRef<"ProfileModel", 'String'>
    readonly fullName: FieldRef<"ProfileModel", 'String'>
    readonly status: FieldRef<"ProfileModel", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ProfileModel findUnique
   */
  export type ProfileModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileModel
     */
    select?: ProfileModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileModelInclude<ExtArgs> | null
    /**
     * Filter, which ProfileModel to fetch.
     */
    where: ProfileModelWhereUniqueInput
  }


  /**
   * ProfileModel findUniqueOrThrow
   */
  export type ProfileModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileModel
     */
    select?: ProfileModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileModelInclude<ExtArgs> | null
    /**
     * Filter, which ProfileModel to fetch.
     */
    where: ProfileModelWhereUniqueInput
  }


  /**
   * ProfileModel findFirst
   */
  export type ProfileModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileModel
     */
    select?: ProfileModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileModelInclude<ExtArgs> | null
    /**
     * Filter, which ProfileModel to fetch.
     */
    where?: ProfileModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileModels to fetch.
     */
    orderBy?: ProfileModelOrderByWithRelationInput | ProfileModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileModels.
     */
    cursor?: ProfileModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileModels.
     */
    distinct?: ProfileModelScalarFieldEnum | ProfileModelScalarFieldEnum[]
  }


  /**
   * ProfileModel findFirstOrThrow
   */
  export type ProfileModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileModel
     */
    select?: ProfileModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileModelInclude<ExtArgs> | null
    /**
     * Filter, which ProfileModel to fetch.
     */
    where?: ProfileModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileModels to fetch.
     */
    orderBy?: ProfileModelOrderByWithRelationInput | ProfileModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileModels.
     */
    cursor?: ProfileModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileModels.
     */
    distinct?: ProfileModelScalarFieldEnum | ProfileModelScalarFieldEnum[]
  }


  /**
   * ProfileModel findMany
   */
  export type ProfileModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileModel
     */
    select?: ProfileModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileModelInclude<ExtArgs> | null
    /**
     * Filter, which ProfileModels to fetch.
     */
    where?: ProfileModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileModels to fetch.
     */
    orderBy?: ProfileModelOrderByWithRelationInput | ProfileModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileModels.
     */
    cursor?: ProfileModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileModels.
     */
    skip?: number
    distinct?: ProfileModelScalarFieldEnum | ProfileModelScalarFieldEnum[]
  }


  /**
   * ProfileModel create
   */
  export type ProfileModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileModel
     */
    select?: ProfileModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileModelInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileModel.
     */
    data: XOR<ProfileModelCreateInput, ProfileModelUncheckedCreateInput>
  }


  /**
   * ProfileModel update
   */
  export type ProfileModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileModel
     */
    select?: ProfileModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileModelInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileModel.
     */
    data: XOR<ProfileModelUpdateInput, ProfileModelUncheckedUpdateInput>
    /**
     * Choose, which ProfileModel to update.
     */
    where: ProfileModelWhereUniqueInput
  }


  /**
   * ProfileModel updateMany
   */
  export type ProfileModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileModels.
     */
    data: XOR<ProfileModelUpdateManyMutationInput, ProfileModelUncheckedUpdateManyInput>
    /**
     * Filter which ProfileModels to update
     */
    where?: ProfileModelWhereInput
  }


  /**
   * ProfileModel upsert
   */
  export type ProfileModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileModel
     */
    select?: ProfileModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileModelInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileModel to update in case it exists.
     */
    where: ProfileModelWhereUniqueInput
    /**
     * In case the ProfileModel found by the `where` argument doesn't exist, create a new ProfileModel with this data.
     */
    create: XOR<ProfileModelCreateInput, ProfileModelUncheckedCreateInput>
    /**
     * In case the ProfileModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileModelUpdateInput, ProfileModelUncheckedUpdateInput>
  }


  /**
   * ProfileModel delete
   */
  export type ProfileModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileModel
     */
    select?: ProfileModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileModelInclude<ExtArgs> | null
    /**
     * Filter which ProfileModel to delete.
     */
    where: ProfileModelWhereUniqueInput
  }


  /**
   * ProfileModel deleteMany
   */
  export type ProfileModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileModels to delete
     */
    where?: ProfileModelWhereInput
  }


  /**
   * ProfileModel.contacts
   */
  export type ProfileModel$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsModel
     */
    select?: ContactsModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsModelInclude<ExtArgs> | null
    where?: ContactsModelWhereInput
  }


  /**
   * ProfileModel.photos
   */
  export type ProfileModel$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotosModel
     */
    select?: PhotosModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotosModelInclude<ExtArgs> | null
    where?: PhotosModelWhereInput
  }


  /**
   * ProfileModel without action
   */
  export type ProfileModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileModel
     */
    select?: ProfileModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileModelInclude<ExtArgs> | null
  }



  /**
   * Model ContactsModel
   */

  export type AggregateContactsModel = {
    _count: ContactsModelCountAggregateOutputType | null
    _avg: ContactsModelAvgAggregateOutputType | null
    _sum: ContactsModelSumAggregateOutputType | null
    _min: ContactsModelMinAggregateOutputType | null
    _max: ContactsModelMaxAggregateOutputType | null
  }

  export type ContactsModelAvgAggregateOutputType = {
    profileId: number | null
  }

  export type ContactsModelSumAggregateOutputType = {
    profileId: number | null
  }

  export type ContactsModelMinAggregateOutputType = {
    github: string | null
    facebook: string | null
    instagram: string | null
    twitter: string | null
    website: string | null
    youtube: string | null
    mainLink: string | null
    profileId: number | null
  }

  export type ContactsModelMaxAggregateOutputType = {
    github: string | null
    facebook: string | null
    instagram: string | null
    twitter: string | null
    website: string | null
    youtube: string | null
    mainLink: string | null
    profileId: number | null
  }

  export type ContactsModelCountAggregateOutputType = {
    github: number
    facebook: number
    instagram: number
    twitter: number
    website: number
    youtube: number
    mainLink: number
    profileId: number
    _all: number
  }


  export type ContactsModelAvgAggregateInputType = {
    profileId?: true
  }

  export type ContactsModelSumAggregateInputType = {
    profileId?: true
  }

  export type ContactsModelMinAggregateInputType = {
    github?: true
    facebook?: true
    instagram?: true
    twitter?: true
    website?: true
    youtube?: true
    mainLink?: true
    profileId?: true
  }

  export type ContactsModelMaxAggregateInputType = {
    github?: true
    facebook?: true
    instagram?: true
    twitter?: true
    website?: true
    youtube?: true
    mainLink?: true
    profileId?: true
  }

  export type ContactsModelCountAggregateInputType = {
    github?: true
    facebook?: true
    instagram?: true
    twitter?: true
    website?: true
    youtube?: true
    mainLink?: true
    profileId?: true
    _all?: true
  }

  export type ContactsModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactsModel to aggregate.
     */
    where?: ContactsModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactsModels to fetch.
     */
    orderBy?: ContactsModelOrderByWithRelationInput | ContactsModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactsModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactsModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactsModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactsModels
    **/
    _count?: true | ContactsModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactsModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactsModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactsModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactsModelMaxAggregateInputType
  }

  export type GetContactsModelAggregateType<T extends ContactsModelAggregateArgs> = {
        [P in keyof T & keyof AggregateContactsModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactsModel[P]>
      : GetScalarType<T[P], AggregateContactsModel[P]>
  }




  export type ContactsModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactsModelWhereInput
    orderBy?: ContactsModelOrderByWithAggregationInput | ContactsModelOrderByWithAggregationInput[]
    by: ContactsModelScalarFieldEnum[] | ContactsModelScalarFieldEnum
    having?: ContactsModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactsModelCountAggregateInputType | true
    _avg?: ContactsModelAvgAggregateInputType
    _sum?: ContactsModelSumAggregateInputType
    _min?: ContactsModelMinAggregateInputType
    _max?: ContactsModelMaxAggregateInputType
  }

  export type ContactsModelGroupByOutputType = {
    github: string | null
    facebook: string | null
    instagram: string | null
    twitter: string | null
    website: string | null
    youtube: string | null
    mainLink: string | null
    profileId: number
    _count: ContactsModelCountAggregateOutputType | null
    _avg: ContactsModelAvgAggregateOutputType | null
    _sum: ContactsModelSumAggregateOutputType | null
    _min: ContactsModelMinAggregateOutputType | null
    _max: ContactsModelMaxAggregateOutputType | null
  }

  type GetContactsModelGroupByPayload<T extends ContactsModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactsModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactsModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactsModelGroupByOutputType[P]>
            : GetScalarType<T[P], ContactsModelGroupByOutputType[P]>
        }
      >
    >


  export type ContactsModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    github?: boolean
    facebook?: boolean
    instagram?: boolean
    twitter?: boolean
    website?: boolean
    youtube?: boolean
    mainLink?: boolean
    profileId?: boolean
    profile?: boolean | ProfileModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactsModel"]>

  export type ContactsModelSelectScalar = {
    github?: boolean
    facebook?: boolean
    instagram?: boolean
    twitter?: boolean
    website?: boolean
    youtube?: boolean
    mainLink?: boolean
    profileId?: boolean
  }

  export type ContactsModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileModelDefaultArgs<ExtArgs>
  }


  export type $ContactsModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactsModel"
    objects: {
      profile: Prisma.$ProfileModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      github: string | null
      facebook: string | null
      instagram: string | null
      twitter: string | null
      website: string | null
      youtube: string | null
      mainLink: string | null
      profileId: number
    }, ExtArgs["result"]["contactsModel"]>
    composites: {}
  }


  type ContactsModelGetPayload<S extends boolean | null | undefined | ContactsModelDefaultArgs> = $Result.GetResult<Prisma.$ContactsModelPayload, S>

  type ContactsModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactsModelFindManyArgs, 'select' | 'include'> & {
      select?: ContactsModelCountAggregateInputType | true
    }

  export interface ContactsModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactsModel'], meta: { name: 'ContactsModel' } }
    /**
     * Find zero or one ContactsModel that matches the filter.
     * @param {ContactsModelFindUniqueArgs} args - Arguments to find a ContactsModel
     * @example
     * // Get one ContactsModel
     * const contactsModel = await prisma.contactsModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContactsModelFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsModelFindUniqueArgs<ExtArgs>>
    ): Prisma__ContactsModelClient<$Result.GetResult<Prisma.$ContactsModelPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ContactsModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContactsModelFindUniqueOrThrowArgs} args - Arguments to find a ContactsModel
     * @example
     * // Get one ContactsModel
     * const contactsModel = await prisma.contactsModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContactsModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContactsModelClient<$Result.GetResult<Prisma.$ContactsModelPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ContactsModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsModelFindFirstArgs} args - Arguments to find a ContactsModel
     * @example
     * // Get one ContactsModel
     * const contactsModel = await prisma.contactsModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContactsModelFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsModelFindFirstArgs<ExtArgs>>
    ): Prisma__ContactsModelClient<$Result.GetResult<Prisma.$ContactsModelPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ContactsModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsModelFindFirstOrThrowArgs} args - Arguments to find a ContactsModel
     * @example
     * // Get one ContactsModel
     * const contactsModel = await prisma.contactsModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContactsModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContactsModelClient<$Result.GetResult<Prisma.$ContactsModelPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ContactsModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactsModels
     * const contactsModels = await prisma.contactsModel.findMany()
     * 
     * // Get first 10 ContactsModels
     * const contactsModels = await prisma.contactsModel.findMany({ take: 10 })
     * 
     * // Only select the `github`
     * const contactsModelWithGithubOnly = await prisma.contactsModel.findMany({ select: { github: true } })
     * 
    **/
    findMany<T extends ContactsModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsModelPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ContactsModel.
     * @param {ContactsModelCreateArgs} args - Arguments to create a ContactsModel.
     * @example
     * // Create one ContactsModel
     * const ContactsModel = await prisma.contactsModel.create({
     *   data: {
     *     // ... data to create a ContactsModel
     *   }
     * })
     * 
    **/
    create<T extends ContactsModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsModelCreateArgs<ExtArgs>>
    ): Prisma__ContactsModelClient<$Result.GetResult<Prisma.$ContactsModelPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a ContactsModel.
     * @param {ContactsModelDeleteArgs} args - Arguments to delete one ContactsModel.
     * @example
     * // Delete one ContactsModel
     * const ContactsModel = await prisma.contactsModel.delete({
     *   where: {
     *     // ... filter to delete one ContactsModel
     *   }
     * })
     * 
    **/
    delete<T extends ContactsModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsModelDeleteArgs<ExtArgs>>
    ): Prisma__ContactsModelClient<$Result.GetResult<Prisma.$ContactsModelPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ContactsModel.
     * @param {ContactsModelUpdateArgs} args - Arguments to update one ContactsModel.
     * @example
     * // Update one ContactsModel
     * const contactsModel = await prisma.contactsModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContactsModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsModelUpdateArgs<ExtArgs>>
    ): Prisma__ContactsModelClient<$Result.GetResult<Prisma.$ContactsModelPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ContactsModels.
     * @param {ContactsModelDeleteManyArgs} args - Arguments to filter ContactsModels to delete.
     * @example
     * // Delete a few ContactsModels
     * const { count } = await prisma.contactsModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContactsModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactsModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactsModels
     * const contactsModel = await prisma.contactsModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContactsModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactsModel.
     * @param {ContactsModelUpsertArgs} args - Arguments to update or create a ContactsModel.
     * @example
     * // Update or create a ContactsModel
     * const contactsModel = await prisma.contactsModel.upsert({
     *   create: {
     *     // ... data to create a ContactsModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactsModel we want to update
     *   }
     * })
    **/
    upsert<T extends ContactsModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsModelUpsertArgs<ExtArgs>>
    ): Prisma__ContactsModelClient<$Result.GetResult<Prisma.$ContactsModelPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ContactsModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsModelCountArgs} args - Arguments to filter ContactsModels to count.
     * @example
     * // Count the number of ContactsModels
     * const count = await prisma.contactsModel.count({
     *   where: {
     *     // ... the filter for the ContactsModels we want to count
     *   }
     * })
    **/
    count<T extends ContactsModelCountArgs>(
      args?: Subset<T, ContactsModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactsModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactsModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactsModelAggregateArgs>(args: Subset<T, ContactsModelAggregateArgs>): Prisma.PrismaPromise<GetContactsModelAggregateType<T>>

    /**
     * Group by ContactsModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactsModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactsModelGroupByArgs['orderBy'] }
        : { orderBy?: ContactsModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactsModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactsModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactsModel model
   */
  readonly fields: ContactsModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactsModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactsModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    profile<T extends ProfileModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileModelDefaultArgs<ExtArgs>>): Prisma__ProfileModelClient<$Result.GetResult<Prisma.$ProfileModelPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ContactsModel model
   */ 
  interface ContactsModelFieldRefs {
    readonly github: FieldRef<"ContactsModel", 'String'>
    readonly facebook: FieldRef<"ContactsModel", 'String'>
    readonly instagram: FieldRef<"ContactsModel", 'String'>
    readonly twitter: FieldRef<"ContactsModel", 'String'>
    readonly website: FieldRef<"ContactsModel", 'String'>
    readonly youtube: FieldRef<"ContactsModel", 'String'>
    readonly mainLink: FieldRef<"ContactsModel", 'String'>
    readonly profileId: FieldRef<"ContactsModel", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ContactsModel findUnique
   */
  export type ContactsModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsModel
     */
    select?: ContactsModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsModelInclude<ExtArgs> | null
    /**
     * Filter, which ContactsModel to fetch.
     */
    where: ContactsModelWhereUniqueInput
  }


  /**
   * ContactsModel findUniqueOrThrow
   */
  export type ContactsModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsModel
     */
    select?: ContactsModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsModelInclude<ExtArgs> | null
    /**
     * Filter, which ContactsModel to fetch.
     */
    where: ContactsModelWhereUniqueInput
  }


  /**
   * ContactsModel findFirst
   */
  export type ContactsModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsModel
     */
    select?: ContactsModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsModelInclude<ExtArgs> | null
    /**
     * Filter, which ContactsModel to fetch.
     */
    where?: ContactsModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactsModels to fetch.
     */
    orderBy?: ContactsModelOrderByWithRelationInput | ContactsModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactsModels.
     */
    cursor?: ContactsModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactsModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactsModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactsModels.
     */
    distinct?: ContactsModelScalarFieldEnum | ContactsModelScalarFieldEnum[]
  }


  /**
   * ContactsModel findFirstOrThrow
   */
  export type ContactsModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsModel
     */
    select?: ContactsModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsModelInclude<ExtArgs> | null
    /**
     * Filter, which ContactsModel to fetch.
     */
    where?: ContactsModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactsModels to fetch.
     */
    orderBy?: ContactsModelOrderByWithRelationInput | ContactsModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactsModels.
     */
    cursor?: ContactsModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactsModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactsModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactsModels.
     */
    distinct?: ContactsModelScalarFieldEnum | ContactsModelScalarFieldEnum[]
  }


  /**
   * ContactsModel findMany
   */
  export type ContactsModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsModel
     */
    select?: ContactsModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsModelInclude<ExtArgs> | null
    /**
     * Filter, which ContactsModels to fetch.
     */
    where?: ContactsModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactsModels to fetch.
     */
    orderBy?: ContactsModelOrderByWithRelationInput | ContactsModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactsModels.
     */
    cursor?: ContactsModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactsModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactsModels.
     */
    skip?: number
    distinct?: ContactsModelScalarFieldEnum | ContactsModelScalarFieldEnum[]
  }


  /**
   * ContactsModel create
   */
  export type ContactsModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsModel
     */
    select?: ContactsModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsModelInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactsModel.
     */
    data: XOR<ContactsModelCreateInput, ContactsModelUncheckedCreateInput>
  }


  /**
   * ContactsModel update
   */
  export type ContactsModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsModel
     */
    select?: ContactsModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsModelInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactsModel.
     */
    data: XOR<ContactsModelUpdateInput, ContactsModelUncheckedUpdateInput>
    /**
     * Choose, which ContactsModel to update.
     */
    where: ContactsModelWhereUniqueInput
  }


  /**
   * ContactsModel updateMany
   */
  export type ContactsModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactsModels.
     */
    data: XOR<ContactsModelUpdateManyMutationInput, ContactsModelUncheckedUpdateManyInput>
    /**
     * Filter which ContactsModels to update
     */
    where?: ContactsModelWhereInput
  }


  /**
   * ContactsModel upsert
   */
  export type ContactsModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsModel
     */
    select?: ContactsModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsModelInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactsModel to update in case it exists.
     */
    where: ContactsModelWhereUniqueInput
    /**
     * In case the ContactsModel found by the `where` argument doesn't exist, create a new ContactsModel with this data.
     */
    create: XOR<ContactsModelCreateInput, ContactsModelUncheckedCreateInput>
    /**
     * In case the ContactsModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactsModelUpdateInput, ContactsModelUncheckedUpdateInput>
  }


  /**
   * ContactsModel delete
   */
  export type ContactsModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsModel
     */
    select?: ContactsModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsModelInclude<ExtArgs> | null
    /**
     * Filter which ContactsModel to delete.
     */
    where: ContactsModelWhereUniqueInput
  }


  /**
   * ContactsModel deleteMany
   */
  export type ContactsModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactsModels to delete
     */
    where?: ContactsModelWhereInput
  }


  /**
   * ContactsModel without action
   */
  export type ContactsModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsModel
     */
    select?: ContactsModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsModelInclude<ExtArgs> | null
  }



  /**
   * Model PhotosModel
   */

  export type AggregatePhotosModel = {
    _count: PhotosModelCountAggregateOutputType | null
    _avg: PhotosModelAvgAggregateOutputType | null
    _sum: PhotosModelSumAggregateOutputType | null
    _min: PhotosModelMinAggregateOutputType | null
    _max: PhotosModelMaxAggregateOutputType | null
  }

  export type PhotosModelAvgAggregateOutputType = {
    profileId: number | null
  }

  export type PhotosModelSumAggregateOutputType = {
    profileId: number | null
  }

  export type PhotosModelMinAggregateOutputType = {
    small: string | null
    large: string | null
    profileId: number | null
  }

  export type PhotosModelMaxAggregateOutputType = {
    small: string | null
    large: string | null
    profileId: number | null
  }

  export type PhotosModelCountAggregateOutputType = {
    small: number
    large: number
    profileId: number
    _all: number
  }


  export type PhotosModelAvgAggregateInputType = {
    profileId?: true
  }

  export type PhotosModelSumAggregateInputType = {
    profileId?: true
  }

  export type PhotosModelMinAggregateInputType = {
    small?: true
    large?: true
    profileId?: true
  }

  export type PhotosModelMaxAggregateInputType = {
    small?: true
    large?: true
    profileId?: true
  }

  export type PhotosModelCountAggregateInputType = {
    small?: true
    large?: true
    profileId?: true
    _all?: true
  }

  export type PhotosModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhotosModel to aggregate.
     */
    where?: PhotosModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotosModels to fetch.
     */
    orderBy?: PhotosModelOrderByWithRelationInput | PhotosModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhotosModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotosModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotosModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhotosModels
    **/
    _count?: true | PhotosModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhotosModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhotosModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotosModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotosModelMaxAggregateInputType
  }

  export type GetPhotosModelAggregateType<T extends PhotosModelAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotosModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotosModel[P]>
      : GetScalarType<T[P], AggregatePhotosModel[P]>
  }




  export type PhotosModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotosModelWhereInput
    orderBy?: PhotosModelOrderByWithAggregationInput | PhotosModelOrderByWithAggregationInput[]
    by: PhotosModelScalarFieldEnum[] | PhotosModelScalarFieldEnum
    having?: PhotosModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotosModelCountAggregateInputType | true
    _avg?: PhotosModelAvgAggregateInputType
    _sum?: PhotosModelSumAggregateInputType
    _min?: PhotosModelMinAggregateInputType
    _max?: PhotosModelMaxAggregateInputType
  }

  export type PhotosModelGroupByOutputType = {
    small: string | null
    large: string | null
    profileId: number
    _count: PhotosModelCountAggregateOutputType | null
    _avg: PhotosModelAvgAggregateOutputType | null
    _sum: PhotosModelSumAggregateOutputType | null
    _min: PhotosModelMinAggregateOutputType | null
    _max: PhotosModelMaxAggregateOutputType | null
  }

  type GetPhotosModelGroupByPayload<T extends PhotosModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhotosModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotosModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotosModelGroupByOutputType[P]>
            : GetScalarType<T[P], PhotosModelGroupByOutputType[P]>
        }
      >
    >


  export type PhotosModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    small?: boolean
    large?: boolean
    profileId?: boolean
    profile?: boolean | ProfileModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photosModel"]>

  export type PhotosModelSelectScalar = {
    small?: boolean
    large?: boolean
    profileId?: boolean
  }

  export type PhotosModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileModelDefaultArgs<ExtArgs>
  }


  export type $PhotosModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhotosModel"
    objects: {
      profile: Prisma.$ProfileModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      small: string | null
      large: string | null
      profileId: number
    }, ExtArgs["result"]["photosModel"]>
    composites: {}
  }


  type PhotosModelGetPayload<S extends boolean | null | undefined | PhotosModelDefaultArgs> = $Result.GetResult<Prisma.$PhotosModelPayload, S>

  type PhotosModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PhotosModelFindManyArgs, 'select' | 'include'> & {
      select?: PhotosModelCountAggregateInputType | true
    }

  export interface PhotosModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhotosModel'], meta: { name: 'PhotosModel' } }
    /**
     * Find zero or one PhotosModel that matches the filter.
     * @param {PhotosModelFindUniqueArgs} args - Arguments to find a PhotosModel
     * @example
     * // Get one PhotosModel
     * const photosModel = await prisma.photosModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PhotosModelFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PhotosModelFindUniqueArgs<ExtArgs>>
    ): Prisma__PhotosModelClient<$Result.GetResult<Prisma.$PhotosModelPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PhotosModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PhotosModelFindUniqueOrThrowArgs} args - Arguments to find a PhotosModel
     * @example
     * // Get one PhotosModel
     * const photosModel = await prisma.photosModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PhotosModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotosModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PhotosModelClient<$Result.GetResult<Prisma.$PhotosModelPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PhotosModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotosModelFindFirstArgs} args - Arguments to find a PhotosModel
     * @example
     * // Get one PhotosModel
     * const photosModel = await prisma.photosModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PhotosModelFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotosModelFindFirstArgs<ExtArgs>>
    ): Prisma__PhotosModelClient<$Result.GetResult<Prisma.$PhotosModelPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PhotosModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotosModelFindFirstOrThrowArgs} args - Arguments to find a PhotosModel
     * @example
     * // Get one PhotosModel
     * const photosModel = await prisma.photosModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PhotosModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotosModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PhotosModelClient<$Result.GetResult<Prisma.$PhotosModelPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PhotosModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotosModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhotosModels
     * const photosModels = await prisma.photosModel.findMany()
     * 
     * // Get first 10 PhotosModels
     * const photosModels = await prisma.photosModel.findMany({ take: 10 })
     * 
     * // Only select the `small`
     * const photosModelWithSmallOnly = await prisma.photosModel.findMany({ select: { small: true } })
     * 
    **/
    findMany<T extends PhotosModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotosModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotosModelPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PhotosModel.
     * @param {PhotosModelCreateArgs} args - Arguments to create a PhotosModel.
     * @example
     * // Create one PhotosModel
     * const PhotosModel = await prisma.photosModel.create({
     *   data: {
     *     // ... data to create a PhotosModel
     *   }
     * })
     * 
    **/
    create<T extends PhotosModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PhotosModelCreateArgs<ExtArgs>>
    ): Prisma__PhotosModelClient<$Result.GetResult<Prisma.$PhotosModelPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a PhotosModel.
     * @param {PhotosModelDeleteArgs} args - Arguments to delete one PhotosModel.
     * @example
     * // Delete one PhotosModel
     * const PhotosModel = await prisma.photosModel.delete({
     *   where: {
     *     // ... filter to delete one PhotosModel
     *   }
     * })
     * 
    **/
    delete<T extends PhotosModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PhotosModelDeleteArgs<ExtArgs>>
    ): Prisma__PhotosModelClient<$Result.GetResult<Prisma.$PhotosModelPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PhotosModel.
     * @param {PhotosModelUpdateArgs} args - Arguments to update one PhotosModel.
     * @example
     * // Update one PhotosModel
     * const photosModel = await prisma.photosModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PhotosModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PhotosModelUpdateArgs<ExtArgs>>
    ): Prisma__PhotosModelClient<$Result.GetResult<Prisma.$PhotosModelPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PhotosModels.
     * @param {PhotosModelDeleteManyArgs} args - Arguments to filter PhotosModels to delete.
     * @example
     * // Delete a few PhotosModels
     * const { count } = await prisma.photosModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PhotosModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotosModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhotosModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotosModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhotosModels
     * const photosModel = await prisma.photosModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PhotosModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PhotosModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PhotosModel.
     * @param {PhotosModelUpsertArgs} args - Arguments to update or create a PhotosModel.
     * @example
     * // Update or create a PhotosModel
     * const photosModel = await prisma.photosModel.upsert({
     *   create: {
     *     // ... data to create a PhotosModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhotosModel we want to update
     *   }
     * })
    **/
    upsert<T extends PhotosModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PhotosModelUpsertArgs<ExtArgs>>
    ): Prisma__PhotosModelClient<$Result.GetResult<Prisma.$PhotosModelPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PhotosModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotosModelCountArgs} args - Arguments to filter PhotosModels to count.
     * @example
     * // Count the number of PhotosModels
     * const count = await prisma.photosModel.count({
     *   where: {
     *     // ... the filter for the PhotosModels we want to count
     *   }
     * })
    **/
    count<T extends PhotosModelCountArgs>(
      args?: Subset<T, PhotosModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotosModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhotosModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotosModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotosModelAggregateArgs>(args: Subset<T, PhotosModelAggregateArgs>): Prisma.PrismaPromise<GetPhotosModelAggregateType<T>>

    /**
     * Group by PhotosModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotosModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhotosModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhotosModelGroupByArgs['orderBy'] }
        : { orderBy?: PhotosModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhotosModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotosModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhotosModel model
   */
  readonly fields: PhotosModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhotosModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhotosModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    profile<T extends ProfileModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileModelDefaultArgs<ExtArgs>>): Prisma__ProfileModelClient<$Result.GetResult<Prisma.$ProfileModelPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PhotosModel model
   */ 
  interface PhotosModelFieldRefs {
    readonly small: FieldRef<"PhotosModel", 'String'>
    readonly large: FieldRef<"PhotosModel", 'String'>
    readonly profileId: FieldRef<"PhotosModel", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * PhotosModel findUnique
   */
  export type PhotosModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotosModel
     */
    select?: PhotosModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotosModelInclude<ExtArgs> | null
    /**
     * Filter, which PhotosModel to fetch.
     */
    where: PhotosModelWhereUniqueInput
  }


  /**
   * PhotosModel findUniqueOrThrow
   */
  export type PhotosModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotosModel
     */
    select?: PhotosModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotosModelInclude<ExtArgs> | null
    /**
     * Filter, which PhotosModel to fetch.
     */
    where: PhotosModelWhereUniqueInput
  }


  /**
   * PhotosModel findFirst
   */
  export type PhotosModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotosModel
     */
    select?: PhotosModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotosModelInclude<ExtArgs> | null
    /**
     * Filter, which PhotosModel to fetch.
     */
    where?: PhotosModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotosModels to fetch.
     */
    orderBy?: PhotosModelOrderByWithRelationInput | PhotosModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotosModels.
     */
    cursor?: PhotosModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotosModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotosModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotosModels.
     */
    distinct?: PhotosModelScalarFieldEnum | PhotosModelScalarFieldEnum[]
  }


  /**
   * PhotosModel findFirstOrThrow
   */
  export type PhotosModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotosModel
     */
    select?: PhotosModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotosModelInclude<ExtArgs> | null
    /**
     * Filter, which PhotosModel to fetch.
     */
    where?: PhotosModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotosModels to fetch.
     */
    orderBy?: PhotosModelOrderByWithRelationInput | PhotosModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotosModels.
     */
    cursor?: PhotosModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotosModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotosModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotosModels.
     */
    distinct?: PhotosModelScalarFieldEnum | PhotosModelScalarFieldEnum[]
  }


  /**
   * PhotosModel findMany
   */
  export type PhotosModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotosModel
     */
    select?: PhotosModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotosModelInclude<ExtArgs> | null
    /**
     * Filter, which PhotosModels to fetch.
     */
    where?: PhotosModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotosModels to fetch.
     */
    orderBy?: PhotosModelOrderByWithRelationInput | PhotosModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhotosModels.
     */
    cursor?: PhotosModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotosModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotosModels.
     */
    skip?: number
    distinct?: PhotosModelScalarFieldEnum | PhotosModelScalarFieldEnum[]
  }


  /**
   * PhotosModel create
   */
  export type PhotosModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotosModel
     */
    select?: PhotosModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotosModelInclude<ExtArgs> | null
    /**
     * The data needed to create a PhotosModel.
     */
    data: XOR<PhotosModelCreateInput, PhotosModelUncheckedCreateInput>
  }


  /**
   * PhotosModel update
   */
  export type PhotosModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotosModel
     */
    select?: PhotosModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotosModelInclude<ExtArgs> | null
    /**
     * The data needed to update a PhotosModel.
     */
    data: XOR<PhotosModelUpdateInput, PhotosModelUncheckedUpdateInput>
    /**
     * Choose, which PhotosModel to update.
     */
    where: PhotosModelWhereUniqueInput
  }


  /**
   * PhotosModel updateMany
   */
  export type PhotosModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhotosModels.
     */
    data: XOR<PhotosModelUpdateManyMutationInput, PhotosModelUncheckedUpdateManyInput>
    /**
     * Filter which PhotosModels to update
     */
    where?: PhotosModelWhereInput
  }


  /**
   * PhotosModel upsert
   */
  export type PhotosModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotosModel
     */
    select?: PhotosModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotosModelInclude<ExtArgs> | null
    /**
     * The filter to search for the PhotosModel to update in case it exists.
     */
    where: PhotosModelWhereUniqueInput
    /**
     * In case the PhotosModel found by the `where` argument doesn't exist, create a new PhotosModel with this data.
     */
    create: XOR<PhotosModelCreateInput, PhotosModelUncheckedCreateInput>
    /**
     * In case the PhotosModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhotosModelUpdateInput, PhotosModelUncheckedUpdateInput>
  }


  /**
   * PhotosModel delete
   */
  export type PhotosModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotosModel
     */
    select?: PhotosModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotosModelInclude<ExtArgs> | null
    /**
     * Filter which PhotosModel to delete.
     */
    where: PhotosModelWhereUniqueInput
  }


  /**
   * PhotosModel deleteMany
   */
  export type PhotosModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhotosModels to delete
     */
    where?: PhotosModelWhereInput
  }


  /**
   * PhotosModel without action
   */
  export type PhotosModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotosModel
     */
    select?: PhotosModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotosModelInclude<ExtArgs> | null
  }



  /**
   * Model DialogModel
   */

  export type AggregateDialogModel = {
    _count: DialogModelCountAggregateOutputType | null
    _avg: DialogModelAvgAggregateOutputType | null
    _sum: DialogModelSumAggregateOutputType | null
    _min: DialogModelMinAggregateOutputType | null
    _max: DialogModelMaxAggregateOutputType | null
  }

  export type DialogModelAvgAggregateOutputType = {
    id: number | null
  }

  export type DialogModelSumAggregateOutputType = {
    id: number | null
  }

  export type DialogModelMinAggregateOutputType = {
    id: number | null
    members: string | null
  }

  export type DialogModelMaxAggregateOutputType = {
    id: number | null
    members: string | null
  }

  export type DialogModelCountAggregateOutputType = {
    id: number
    members: number
    _all: number
  }


  export type DialogModelAvgAggregateInputType = {
    id?: true
  }

  export type DialogModelSumAggregateInputType = {
    id?: true
  }

  export type DialogModelMinAggregateInputType = {
    id?: true
    members?: true
  }

  export type DialogModelMaxAggregateInputType = {
    id?: true
    members?: true
  }

  export type DialogModelCountAggregateInputType = {
    id?: true
    members?: true
    _all?: true
  }

  export type DialogModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DialogModel to aggregate.
     */
    where?: DialogModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DialogModels to fetch.
     */
    orderBy?: DialogModelOrderByWithRelationInput | DialogModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DialogModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DialogModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DialogModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DialogModels
    **/
    _count?: true | DialogModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DialogModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DialogModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DialogModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DialogModelMaxAggregateInputType
  }

  export type GetDialogModelAggregateType<T extends DialogModelAggregateArgs> = {
        [P in keyof T & keyof AggregateDialogModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDialogModel[P]>
      : GetScalarType<T[P], AggregateDialogModel[P]>
  }




  export type DialogModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DialogModelWhereInput
    orderBy?: DialogModelOrderByWithAggregationInput | DialogModelOrderByWithAggregationInput[]
    by: DialogModelScalarFieldEnum[] | DialogModelScalarFieldEnum
    having?: DialogModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DialogModelCountAggregateInputType | true
    _avg?: DialogModelAvgAggregateInputType
    _sum?: DialogModelSumAggregateInputType
    _min?: DialogModelMinAggregateInputType
    _max?: DialogModelMaxAggregateInputType
  }

  export type DialogModelGroupByOutputType = {
    id: number
    members: string
    _count: DialogModelCountAggregateOutputType | null
    _avg: DialogModelAvgAggregateOutputType | null
    _sum: DialogModelSumAggregateOutputType | null
    _min: DialogModelMinAggregateOutputType | null
    _max: DialogModelMaxAggregateOutputType | null
  }

  type GetDialogModelGroupByPayload<T extends DialogModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DialogModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DialogModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DialogModelGroupByOutputType[P]>
            : GetScalarType<T[P], DialogModelGroupByOutputType[P]>
        }
      >
    >


  export type DialogModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    members?: boolean
    messages?: boolean | DialogModel$messagesArgs<ExtArgs>
    _count?: boolean | DialogModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dialogModel"]>

  export type DialogModelSelectScalar = {
    id?: boolean
    members?: boolean
  }

  export type DialogModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | DialogModel$messagesArgs<ExtArgs>
    _count?: boolean | DialogModelCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DialogModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DialogModel"
    objects: {
      messages: Prisma.$MessageModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      members: string
    }, ExtArgs["result"]["dialogModel"]>
    composites: {}
  }


  type DialogModelGetPayload<S extends boolean | null | undefined | DialogModelDefaultArgs> = $Result.GetResult<Prisma.$DialogModelPayload, S>

  type DialogModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DialogModelFindManyArgs, 'select' | 'include'> & {
      select?: DialogModelCountAggregateInputType | true
    }

  export interface DialogModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DialogModel'], meta: { name: 'DialogModel' } }
    /**
     * Find zero or one DialogModel that matches the filter.
     * @param {DialogModelFindUniqueArgs} args - Arguments to find a DialogModel
     * @example
     * // Get one DialogModel
     * const dialogModel = await prisma.dialogModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DialogModelFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DialogModelFindUniqueArgs<ExtArgs>>
    ): Prisma__DialogModelClient<$Result.GetResult<Prisma.$DialogModelPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DialogModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DialogModelFindUniqueOrThrowArgs} args - Arguments to find a DialogModel
     * @example
     * // Get one DialogModel
     * const dialogModel = await prisma.dialogModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DialogModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DialogModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DialogModelClient<$Result.GetResult<Prisma.$DialogModelPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DialogModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DialogModelFindFirstArgs} args - Arguments to find a DialogModel
     * @example
     * // Get one DialogModel
     * const dialogModel = await prisma.dialogModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DialogModelFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DialogModelFindFirstArgs<ExtArgs>>
    ): Prisma__DialogModelClient<$Result.GetResult<Prisma.$DialogModelPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DialogModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DialogModelFindFirstOrThrowArgs} args - Arguments to find a DialogModel
     * @example
     * // Get one DialogModel
     * const dialogModel = await prisma.dialogModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DialogModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DialogModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DialogModelClient<$Result.GetResult<Prisma.$DialogModelPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DialogModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DialogModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DialogModels
     * const dialogModels = await prisma.dialogModel.findMany()
     * 
     * // Get first 10 DialogModels
     * const dialogModels = await prisma.dialogModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dialogModelWithIdOnly = await prisma.dialogModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DialogModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DialogModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DialogModelPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DialogModel.
     * @param {DialogModelCreateArgs} args - Arguments to create a DialogModel.
     * @example
     * // Create one DialogModel
     * const DialogModel = await prisma.dialogModel.create({
     *   data: {
     *     // ... data to create a DialogModel
     *   }
     * })
     * 
    **/
    create<T extends DialogModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DialogModelCreateArgs<ExtArgs>>
    ): Prisma__DialogModelClient<$Result.GetResult<Prisma.$DialogModelPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a DialogModel.
     * @param {DialogModelDeleteArgs} args - Arguments to delete one DialogModel.
     * @example
     * // Delete one DialogModel
     * const DialogModel = await prisma.dialogModel.delete({
     *   where: {
     *     // ... filter to delete one DialogModel
     *   }
     * })
     * 
    **/
    delete<T extends DialogModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DialogModelDeleteArgs<ExtArgs>>
    ): Prisma__DialogModelClient<$Result.GetResult<Prisma.$DialogModelPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DialogModel.
     * @param {DialogModelUpdateArgs} args - Arguments to update one DialogModel.
     * @example
     * // Update one DialogModel
     * const dialogModel = await prisma.dialogModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DialogModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DialogModelUpdateArgs<ExtArgs>>
    ): Prisma__DialogModelClient<$Result.GetResult<Prisma.$DialogModelPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DialogModels.
     * @param {DialogModelDeleteManyArgs} args - Arguments to filter DialogModels to delete.
     * @example
     * // Delete a few DialogModels
     * const { count } = await prisma.dialogModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DialogModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DialogModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DialogModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DialogModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DialogModels
     * const dialogModel = await prisma.dialogModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DialogModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DialogModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DialogModel.
     * @param {DialogModelUpsertArgs} args - Arguments to update or create a DialogModel.
     * @example
     * // Update or create a DialogModel
     * const dialogModel = await prisma.dialogModel.upsert({
     *   create: {
     *     // ... data to create a DialogModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DialogModel we want to update
     *   }
     * })
    **/
    upsert<T extends DialogModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DialogModelUpsertArgs<ExtArgs>>
    ): Prisma__DialogModelClient<$Result.GetResult<Prisma.$DialogModelPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DialogModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DialogModelCountArgs} args - Arguments to filter DialogModels to count.
     * @example
     * // Count the number of DialogModels
     * const count = await prisma.dialogModel.count({
     *   where: {
     *     // ... the filter for the DialogModels we want to count
     *   }
     * })
    **/
    count<T extends DialogModelCountArgs>(
      args?: Subset<T, DialogModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DialogModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DialogModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DialogModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DialogModelAggregateArgs>(args: Subset<T, DialogModelAggregateArgs>): Prisma.PrismaPromise<GetDialogModelAggregateType<T>>

    /**
     * Group by DialogModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DialogModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DialogModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DialogModelGroupByArgs['orderBy'] }
        : { orderBy?: DialogModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DialogModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDialogModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DialogModel model
   */
  readonly fields: DialogModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DialogModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DialogModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    messages<T extends DialogModel$messagesArgs<ExtArgs> = {}>(args?: Subset<T, DialogModel$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageModelPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DialogModel model
   */ 
  interface DialogModelFieldRefs {
    readonly id: FieldRef<"DialogModel", 'Int'>
    readonly members: FieldRef<"DialogModel", 'String'>
  }
    

  // Custom InputTypes

  /**
   * DialogModel findUnique
   */
  export type DialogModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DialogModel
     */
    select?: DialogModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DialogModelInclude<ExtArgs> | null
    /**
     * Filter, which DialogModel to fetch.
     */
    where: DialogModelWhereUniqueInput
  }


  /**
   * DialogModel findUniqueOrThrow
   */
  export type DialogModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DialogModel
     */
    select?: DialogModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DialogModelInclude<ExtArgs> | null
    /**
     * Filter, which DialogModel to fetch.
     */
    where: DialogModelWhereUniqueInput
  }


  /**
   * DialogModel findFirst
   */
  export type DialogModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DialogModel
     */
    select?: DialogModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DialogModelInclude<ExtArgs> | null
    /**
     * Filter, which DialogModel to fetch.
     */
    where?: DialogModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DialogModels to fetch.
     */
    orderBy?: DialogModelOrderByWithRelationInput | DialogModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DialogModels.
     */
    cursor?: DialogModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DialogModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DialogModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DialogModels.
     */
    distinct?: DialogModelScalarFieldEnum | DialogModelScalarFieldEnum[]
  }


  /**
   * DialogModel findFirstOrThrow
   */
  export type DialogModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DialogModel
     */
    select?: DialogModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DialogModelInclude<ExtArgs> | null
    /**
     * Filter, which DialogModel to fetch.
     */
    where?: DialogModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DialogModels to fetch.
     */
    orderBy?: DialogModelOrderByWithRelationInput | DialogModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DialogModels.
     */
    cursor?: DialogModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DialogModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DialogModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DialogModels.
     */
    distinct?: DialogModelScalarFieldEnum | DialogModelScalarFieldEnum[]
  }


  /**
   * DialogModel findMany
   */
  export type DialogModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DialogModel
     */
    select?: DialogModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DialogModelInclude<ExtArgs> | null
    /**
     * Filter, which DialogModels to fetch.
     */
    where?: DialogModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DialogModels to fetch.
     */
    orderBy?: DialogModelOrderByWithRelationInput | DialogModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DialogModels.
     */
    cursor?: DialogModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DialogModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DialogModels.
     */
    skip?: number
    distinct?: DialogModelScalarFieldEnum | DialogModelScalarFieldEnum[]
  }


  /**
   * DialogModel create
   */
  export type DialogModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DialogModel
     */
    select?: DialogModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DialogModelInclude<ExtArgs> | null
    /**
     * The data needed to create a DialogModel.
     */
    data: XOR<DialogModelCreateInput, DialogModelUncheckedCreateInput>
  }


  /**
   * DialogModel update
   */
  export type DialogModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DialogModel
     */
    select?: DialogModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DialogModelInclude<ExtArgs> | null
    /**
     * The data needed to update a DialogModel.
     */
    data: XOR<DialogModelUpdateInput, DialogModelUncheckedUpdateInput>
    /**
     * Choose, which DialogModel to update.
     */
    where: DialogModelWhereUniqueInput
  }


  /**
   * DialogModel updateMany
   */
  export type DialogModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DialogModels.
     */
    data: XOR<DialogModelUpdateManyMutationInput, DialogModelUncheckedUpdateManyInput>
    /**
     * Filter which DialogModels to update
     */
    where?: DialogModelWhereInput
  }


  /**
   * DialogModel upsert
   */
  export type DialogModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DialogModel
     */
    select?: DialogModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DialogModelInclude<ExtArgs> | null
    /**
     * The filter to search for the DialogModel to update in case it exists.
     */
    where: DialogModelWhereUniqueInput
    /**
     * In case the DialogModel found by the `where` argument doesn't exist, create a new DialogModel with this data.
     */
    create: XOR<DialogModelCreateInput, DialogModelUncheckedCreateInput>
    /**
     * In case the DialogModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DialogModelUpdateInput, DialogModelUncheckedUpdateInput>
  }


  /**
   * DialogModel delete
   */
  export type DialogModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DialogModel
     */
    select?: DialogModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DialogModelInclude<ExtArgs> | null
    /**
     * Filter which DialogModel to delete.
     */
    where: DialogModelWhereUniqueInput
  }


  /**
   * DialogModel deleteMany
   */
  export type DialogModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DialogModels to delete
     */
    where?: DialogModelWhereInput
  }


  /**
   * DialogModel.messages
   */
  export type DialogModel$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageModel
     */
    select?: MessageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageModelInclude<ExtArgs> | null
    where?: MessageModelWhereInput
    orderBy?: MessageModelOrderByWithRelationInput | MessageModelOrderByWithRelationInput[]
    cursor?: MessageModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageModelScalarFieldEnum | MessageModelScalarFieldEnum[]
  }


  /**
   * DialogModel without action
   */
  export type DialogModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DialogModel
     */
    select?: DialogModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DialogModelInclude<ExtArgs> | null
  }



  /**
   * Model MessageModel
   */

  export type AggregateMessageModel = {
    _count: MessageModelCountAggregateOutputType | null
    _avg: MessageModelAvgAggregateOutputType | null
    _sum: MessageModelSumAggregateOutputType | null
    _min: MessageModelMinAggregateOutputType | null
    _max: MessageModelMaxAggregateOutputType | null
  }

  export type MessageModelAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    dialogId: number | null
  }

  export type MessageModelSumAggregateOutputType = {
    id: number | null
    userId: number | null
    dialogId: number | null
  }

  export type MessageModelMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    userId: number | null
    text: string | null
    dialogId: number | null
  }

  export type MessageModelMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    userId: number | null
    text: string | null
    dialogId: number | null
  }

  export type MessageModelCountAggregateOutputType = {
    id: number
    createdAt: number
    userId: number
    text: number
    dialogId: number
    _all: number
  }


  export type MessageModelAvgAggregateInputType = {
    id?: true
    userId?: true
    dialogId?: true
  }

  export type MessageModelSumAggregateInputType = {
    id?: true
    userId?: true
    dialogId?: true
  }

  export type MessageModelMinAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    text?: true
    dialogId?: true
  }

  export type MessageModelMaxAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    text?: true
    dialogId?: true
  }

  export type MessageModelCountAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    text?: true
    dialogId?: true
    _all?: true
  }

  export type MessageModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageModel to aggregate.
     */
    where?: MessageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageModels to fetch.
     */
    orderBy?: MessageModelOrderByWithRelationInput | MessageModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageModels
    **/
    _count?: true | MessageModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageModelMaxAggregateInputType
  }

  export type GetMessageModelAggregateType<T extends MessageModelAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageModel[P]>
      : GetScalarType<T[P], AggregateMessageModel[P]>
  }




  export type MessageModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageModelWhereInput
    orderBy?: MessageModelOrderByWithAggregationInput | MessageModelOrderByWithAggregationInput[]
    by: MessageModelScalarFieldEnum[] | MessageModelScalarFieldEnum
    having?: MessageModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageModelCountAggregateInputType | true
    _avg?: MessageModelAvgAggregateInputType
    _sum?: MessageModelSumAggregateInputType
    _min?: MessageModelMinAggregateInputType
    _max?: MessageModelMaxAggregateInputType
  }

  export type MessageModelGroupByOutputType = {
    id: number
    createdAt: Date | null
    userId: number
    text: string
    dialogId: number
    _count: MessageModelCountAggregateOutputType | null
    _avg: MessageModelAvgAggregateOutputType | null
    _sum: MessageModelSumAggregateOutputType | null
    _min: MessageModelMinAggregateOutputType | null
    _max: MessageModelMaxAggregateOutputType | null
  }

  type GetMessageModelGroupByPayload<T extends MessageModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageModelGroupByOutputType[P]>
            : GetScalarType<T[P], MessageModelGroupByOutputType[P]>
        }
      >
    >


  export type MessageModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    text?: boolean
    dialogId?: boolean
    dialog?: boolean | DialogModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageModel"]>

  export type MessageModelSelectScalar = {
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    text?: boolean
    dialogId?: boolean
  }

  export type MessageModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dialog?: boolean | DialogModelDefaultArgs<ExtArgs>
  }


  export type $MessageModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageModel"
    objects: {
      dialog: Prisma.$DialogModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date | null
      userId: number
      text: string
      dialogId: number
    }, ExtArgs["result"]["messageModel"]>
    composites: {}
  }


  type MessageModelGetPayload<S extends boolean | null | undefined | MessageModelDefaultArgs> = $Result.GetResult<Prisma.$MessageModelPayload, S>

  type MessageModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageModelFindManyArgs, 'select' | 'include'> & {
      select?: MessageModelCountAggregateInputType | true
    }

  export interface MessageModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageModel'], meta: { name: 'MessageModel' } }
    /**
     * Find zero or one MessageModel that matches the filter.
     * @param {MessageModelFindUniqueArgs} args - Arguments to find a MessageModel
     * @example
     * // Get one MessageModel
     * const messageModel = await prisma.messageModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageModelFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessageModelFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageModelClient<$Result.GetResult<Prisma.$MessageModelPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MessageModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageModelFindUniqueOrThrowArgs} args - Arguments to find a MessageModel
     * @example
     * // Get one MessageModel
     * const messageModel = await prisma.messageModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageModelClient<$Result.GetResult<Prisma.$MessageModelPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MessageModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageModelFindFirstArgs} args - Arguments to find a MessageModel
     * @example
     * // Get one MessageModel
     * const messageModel = await prisma.messageModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageModelFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageModelFindFirstArgs<ExtArgs>>
    ): Prisma__MessageModelClient<$Result.GetResult<Prisma.$MessageModelPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MessageModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageModelFindFirstOrThrowArgs} args - Arguments to find a MessageModel
     * @example
     * // Get one MessageModel
     * const messageModel = await prisma.messageModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageModelClient<$Result.GetResult<Prisma.$MessageModelPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MessageModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageModels
     * const messageModels = await prisma.messageModel.findMany()
     * 
     * // Get first 10 MessageModels
     * const messageModels = await prisma.messageModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageModelWithIdOnly = await prisma.messageModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageModelPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MessageModel.
     * @param {MessageModelCreateArgs} args - Arguments to create a MessageModel.
     * @example
     * // Create one MessageModel
     * const MessageModel = await prisma.messageModel.create({
     *   data: {
     *     // ... data to create a MessageModel
     *   }
     * })
     * 
    **/
    create<T extends MessageModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageModelCreateArgs<ExtArgs>>
    ): Prisma__MessageModelClient<$Result.GetResult<Prisma.$MessageModelPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a MessageModel.
     * @param {MessageModelDeleteArgs} args - Arguments to delete one MessageModel.
     * @example
     * // Delete one MessageModel
     * const MessageModel = await prisma.messageModel.delete({
     *   where: {
     *     // ... filter to delete one MessageModel
     *   }
     * })
     * 
    **/
    delete<T extends MessageModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessageModelDeleteArgs<ExtArgs>>
    ): Prisma__MessageModelClient<$Result.GetResult<Prisma.$MessageModelPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MessageModel.
     * @param {MessageModelUpdateArgs} args - Arguments to update one MessageModel.
     * @example
     * // Update one MessageModel
     * const messageModel = await prisma.messageModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageModelUpdateArgs<ExtArgs>>
    ): Prisma__MessageModelClient<$Result.GetResult<Prisma.$MessageModelPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MessageModels.
     * @param {MessageModelDeleteManyArgs} args - Arguments to filter MessageModels to delete.
     * @example
     * // Delete a few MessageModels
     * const { count } = await prisma.messageModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageModels
     * const messageModel = await prisma.messageModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessageModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageModel.
     * @param {MessageModelUpsertArgs} args - Arguments to update or create a MessageModel.
     * @example
     * // Update or create a MessageModel
     * const messageModel = await prisma.messageModel.upsert({
     *   create: {
     *     // ... data to create a MessageModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageModel we want to update
     *   }
     * })
    **/
    upsert<T extends MessageModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessageModelUpsertArgs<ExtArgs>>
    ): Prisma__MessageModelClient<$Result.GetResult<Prisma.$MessageModelPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MessageModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageModelCountArgs} args - Arguments to filter MessageModels to count.
     * @example
     * // Count the number of MessageModels
     * const count = await prisma.messageModel.count({
     *   where: {
     *     // ... the filter for the MessageModels we want to count
     *   }
     * })
    **/
    count<T extends MessageModelCountArgs>(
      args?: Subset<T, MessageModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageModelAggregateArgs>(args: Subset<T, MessageModelAggregateArgs>): Prisma.PrismaPromise<GetMessageModelAggregateType<T>>

    /**
     * Group by MessageModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageModelGroupByArgs['orderBy'] }
        : { orderBy?: MessageModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageModel model
   */
  readonly fields: MessageModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    dialog<T extends DialogModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DialogModelDefaultArgs<ExtArgs>>): Prisma__DialogModelClient<$Result.GetResult<Prisma.$DialogModelPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MessageModel model
   */ 
  interface MessageModelFieldRefs {
    readonly id: FieldRef<"MessageModel", 'Int'>
    readonly createdAt: FieldRef<"MessageModel", 'DateTime'>
    readonly userId: FieldRef<"MessageModel", 'Int'>
    readonly text: FieldRef<"MessageModel", 'String'>
    readonly dialogId: FieldRef<"MessageModel", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * MessageModel findUnique
   */
  export type MessageModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageModel
     */
    select?: MessageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageModelInclude<ExtArgs> | null
    /**
     * Filter, which MessageModel to fetch.
     */
    where: MessageModelWhereUniqueInput
  }


  /**
   * MessageModel findUniqueOrThrow
   */
  export type MessageModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageModel
     */
    select?: MessageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageModelInclude<ExtArgs> | null
    /**
     * Filter, which MessageModel to fetch.
     */
    where: MessageModelWhereUniqueInput
  }


  /**
   * MessageModel findFirst
   */
  export type MessageModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageModel
     */
    select?: MessageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageModelInclude<ExtArgs> | null
    /**
     * Filter, which MessageModel to fetch.
     */
    where?: MessageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageModels to fetch.
     */
    orderBy?: MessageModelOrderByWithRelationInput | MessageModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageModels.
     */
    cursor?: MessageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageModels.
     */
    distinct?: MessageModelScalarFieldEnum | MessageModelScalarFieldEnum[]
  }


  /**
   * MessageModel findFirstOrThrow
   */
  export type MessageModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageModel
     */
    select?: MessageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageModelInclude<ExtArgs> | null
    /**
     * Filter, which MessageModel to fetch.
     */
    where?: MessageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageModels to fetch.
     */
    orderBy?: MessageModelOrderByWithRelationInput | MessageModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageModels.
     */
    cursor?: MessageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageModels.
     */
    distinct?: MessageModelScalarFieldEnum | MessageModelScalarFieldEnum[]
  }


  /**
   * MessageModel findMany
   */
  export type MessageModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageModel
     */
    select?: MessageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageModelInclude<ExtArgs> | null
    /**
     * Filter, which MessageModels to fetch.
     */
    where?: MessageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageModels to fetch.
     */
    orderBy?: MessageModelOrderByWithRelationInput | MessageModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageModels.
     */
    cursor?: MessageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageModels.
     */
    skip?: number
    distinct?: MessageModelScalarFieldEnum | MessageModelScalarFieldEnum[]
  }


  /**
   * MessageModel create
   */
  export type MessageModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageModel
     */
    select?: MessageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageModelInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageModel.
     */
    data: XOR<MessageModelCreateInput, MessageModelUncheckedCreateInput>
  }


  /**
   * MessageModel update
   */
  export type MessageModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageModel
     */
    select?: MessageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageModelInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageModel.
     */
    data: XOR<MessageModelUpdateInput, MessageModelUncheckedUpdateInput>
    /**
     * Choose, which MessageModel to update.
     */
    where: MessageModelWhereUniqueInput
  }


  /**
   * MessageModel updateMany
   */
  export type MessageModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageModels.
     */
    data: XOR<MessageModelUpdateManyMutationInput, MessageModelUncheckedUpdateManyInput>
    /**
     * Filter which MessageModels to update
     */
    where?: MessageModelWhereInput
  }


  /**
   * MessageModel upsert
   */
  export type MessageModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageModel
     */
    select?: MessageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageModelInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageModel to update in case it exists.
     */
    where: MessageModelWhereUniqueInput
    /**
     * In case the MessageModel found by the `where` argument doesn't exist, create a new MessageModel with this data.
     */
    create: XOR<MessageModelCreateInput, MessageModelUncheckedCreateInput>
    /**
     * In case the MessageModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageModelUpdateInput, MessageModelUncheckedUpdateInput>
  }


  /**
   * MessageModel delete
   */
  export type MessageModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageModel
     */
    select?: MessageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageModelInclude<ExtArgs> | null
    /**
     * Filter which MessageModel to delete.
     */
    where: MessageModelWhereUniqueInput
  }


  /**
   * MessageModel deleteMany
   */
  export type MessageModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageModels to delete
     */
    where?: MessageModelWhereInput
  }


  /**
   * MessageModel without action
   */
  export type MessageModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageModel
     */
    select?: MessageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageModelInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserModelScalarFieldEnum: {
    id: 'id',
    email: 'email',
    login: 'login',
    followed: 'followed',
    dialogs: 'dialogs'
  };

  export type UserModelScalarFieldEnum = (typeof UserModelScalarFieldEnum)[keyof typeof UserModelScalarFieldEnum]


  export const UserPasswordModelScalarFieldEnum: {
    userId: 'userId',
    password: 'password'
  };

  export type UserPasswordModelScalarFieldEnum = (typeof UserPasswordModelScalarFieldEnum)[keyof typeof UserPasswordModelScalarFieldEnum]


  export const ProfileModelScalarFieldEnum: {
    userId: 'userId',
    lookingForAJob: 'lookingForAJob',
    lookingForAJobDescription: 'lookingForAJobDescription',
    fullName: 'fullName',
    status: 'status'
  };

  export type ProfileModelScalarFieldEnum = (typeof ProfileModelScalarFieldEnum)[keyof typeof ProfileModelScalarFieldEnum]


  export const ContactsModelScalarFieldEnum: {
    github: 'github',
    facebook: 'facebook',
    instagram: 'instagram',
    twitter: 'twitter',
    website: 'website',
    youtube: 'youtube',
    mainLink: 'mainLink',
    profileId: 'profileId'
  };

  export type ContactsModelScalarFieldEnum = (typeof ContactsModelScalarFieldEnum)[keyof typeof ContactsModelScalarFieldEnum]


  export const PhotosModelScalarFieldEnum: {
    small: 'small',
    large: 'large',
    profileId: 'profileId'
  };

  export type PhotosModelScalarFieldEnum = (typeof PhotosModelScalarFieldEnum)[keyof typeof PhotosModelScalarFieldEnum]


  export const DialogModelScalarFieldEnum: {
    id: 'id',
    members: 'members'
  };

  export type DialogModelScalarFieldEnum = (typeof DialogModelScalarFieldEnum)[keyof typeof DialogModelScalarFieldEnum]


  export const MessageModelScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    userId: 'userId',
    text: 'text',
    dialogId: 'dialogId'
  };

  export type MessageModelScalarFieldEnum = (typeof MessageModelScalarFieldEnum)[keyof typeof MessageModelScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserModelWhereInput = {
    AND?: UserModelWhereInput | UserModelWhereInput[]
    OR?: UserModelWhereInput[]
    NOT?: UserModelWhereInput | UserModelWhereInput[]
    id?: IntFilter<"UserModel"> | number
    email?: StringFilter<"UserModel"> | string
    login?: StringFilter<"UserModel"> | string
    followed?: StringNullableFilter<"UserModel"> | string | null
    dialogs?: StringNullableFilter<"UserModel"> | string | null
    password?: XOR<UserPasswordModelNullableRelationFilter, UserPasswordModelWhereInput> | null
    profile?: XOR<ProfileModelNullableRelationFilter, ProfileModelWhereInput> | null
  }

  export type UserModelOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    login?: SortOrder
    followed?: SortOrderInput | SortOrder
    dialogs?: SortOrderInput | SortOrder
    password?: UserPasswordModelOrderByWithRelationInput
    profile?: ProfileModelOrderByWithRelationInput
  }

  export type UserModelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserModelWhereInput | UserModelWhereInput[]
    OR?: UserModelWhereInput[]
    NOT?: UserModelWhereInput | UserModelWhereInput[]
    login?: StringFilter<"UserModel"> | string
    followed?: StringNullableFilter<"UserModel"> | string | null
    dialogs?: StringNullableFilter<"UserModel"> | string | null
    password?: XOR<UserPasswordModelNullableRelationFilter, UserPasswordModelWhereInput> | null
    profile?: XOR<ProfileModelNullableRelationFilter, ProfileModelWhereInput> | null
  }, "id" | "email">

  export type UserModelOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    login?: SortOrder
    followed?: SortOrderInput | SortOrder
    dialogs?: SortOrderInput | SortOrder
    _count?: UserModelCountOrderByAggregateInput
    _avg?: UserModelAvgOrderByAggregateInput
    _max?: UserModelMaxOrderByAggregateInput
    _min?: UserModelMinOrderByAggregateInput
    _sum?: UserModelSumOrderByAggregateInput
  }

  export type UserModelScalarWhereWithAggregatesInput = {
    AND?: UserModelScalarWhereWithAggregatesInput | UserModelScalarWhereWithAggregatesInput[]
    OR?: UserModelScalarWhereWithAggregatesInput[]
    NOT?: UserModelScalarWhereWithAggregatesInput | UserModelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserModel"> | number
    email?: StringWithAggregatesFilter<"UserModel"> | string
    login?: StringWithAggregatesFilter<"UserModel"> | string
    followed?: StringNullableWithAggregatesFilter<"UserModel"> | string | null
    dialogs?: StringNullableWithAggregatesFilter<"UserModel"> | string | null
  }

  export type UserPasswordModelWhereInput = {
    AND?: UserPasswordModelWhereInput | UserPasswordModelWhereInput[]
    OR?: UserPasswordModelWhereInput[]
    NOT?: UserPasswordModelWhereInput | UserPasswordModelWhereInput[]
    userId?: IntFilter<"UserPasswordModel"> | number
    password?: StringFilter<"UserPasswordModel"> | string
    user?: XOR<UserModelRelationFilter, UserModelWhereInput>
  }

  export type UserPasswordModelOrderByWithRelationInput = {
    userId?: SortOrder
    password?: SortOrder
    user?: UserModelOrderByWithRelationInput
  }

  export type UserPasswordModelWhereUniqueInput = Prisma.AtLeast<{
    userId?: number
    AND?: UserPasswordModelWhereInput | UserPasswordModelWhereInput[]
    OR?: UserPasswordModelWhereInput[]
    NOT?: UserPasswordModelWhereInput | UserPasswordModelWhereInput[]
    password?: StringFilter<"UserPasswordModel"> | string
    user?: XOR<UserModelRelationFilter, UserModelWhereInput>
  }, "userId">

  export type UserPasswordModelOrderByWithAggregationInput = {
    userId?: SortOrder
    password?: SortOrder
    _count?: UserPasswordModelCountOrderByAggregateInput
    _avg?: UserPasswordModelAvgOrderByAggregateInput
    _max?: UserPasswordModelMaxOrderByAggregateInput
    _min?: UserPasswordModelMinOrderByAggregateInput
    _sum?: UserPasswordModelSumOrderByAggregateInput
  }

  export type UserPasswordModelScalarWhereWithAggregatesInput = {
    AND?: UserPasswordModelScalarWhereWithAggregatesInput | UserPasswordModelScalarWhereWithAggregatesInput[]
    OR?: UserPasswordModelScalarWhereWithAggregatesInput[]
    NOT?: UserPasswordModelScalarWhereWithAggregatesInput | UserPasswordModelScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserPasswordModel"> | number
    password?: StringWithAggregatesFilter<"UserPasswordModel"> | string
  }

  export type ProfileModelWhereInput = {
    AND?: ProfileModelWhereInput | ProfileModelWhereInput[]
    OR?: ProfileModelWhereInput[]
    NOT?: ProfileModelWhereInput | ProfileModelWhereInput[]
    userId?: IntFilter<"ProfileModel"> | number
    lookingForAJob?: BoolFilter<"ProfileModel"> | boolean
    lookingForAJobDescription?: StringNullableFilter<"ProfileModel"> | string | null
    fullName?: StringNullableFilter<"ProfileModel"> | string | null
    status?: StringNullableFilter<"ProfileModel"> | string | null
    user?: XOR<UserModelRelationFilter, UserModelWhereInput>
    contacts?: XOR<ContactsModelNullableRelationFilter, ContactsModelWhereInput> | null
    photos?: XOR<PhotosModelNullableRelationFilter, PhotosModelWhereInput> | null
  }

  export type ProfileModelOrderByWithRelationInput = {
    userId?: SortOrder
    lookingForAJob?: SortOrder
    lookingForAJobDescription?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    user?: UserModelOrderByWithRelationInput
    contacts?: ContactsModelOrderByWithRelationInput
    photos?: PhotosModelOrderByWithRelationInput
  }

  export type ProfileModelWhereUniqueInput = Prisma.AtLeast<{
    userId?: number
    AND?: ProfileModelWhereInput | ProfileModelWhereInput[]
    OR?: ProfileModelWhereInput[]
    NOT?: ProfileModelWhereInput | ProfileModelWhereInput[]
    lookingForAJob?: BoolFilter<"ProfileModel"> | boolean
    lookingForAJobDescription?: StringNullableFilter<"ProfileModel"> | string | null
    fullName?: StringNullableFilter<"ProfileModel"> | string | null
    status?: StringNullableFilter<"ProfileModel"> | string | null
    user?: XOR<UserModelRelationFilter, UserModelWhereInput>
    contacts?: XOR<ContactsModelNullableRelationFilter, ContactsModelWhereInput> | null
    photos?: XOR<PhotosModelNullableRelationFilter, PhotosModelWhereInput> | null
  }, "userId">

  export type ProfileModelOrderByWithAggregationInput = {
    userId?: SortOrder
    lookingForAJob?: SortOrder
    lookingForAJobDescription?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: ProfileModelCountOrderByAggregateInput
    _avg?: ProfileModelAvgOrderByAggregateInput
    _max?: ProfileModelMaxOrderByAggregateInput
    _min?: ProfileModelMinOrderByAggregateInput
    _sum?: ProfileModelSumOrderByAggregateInput
  }

  export type ProfileModelScalarWhereWithAggregatesInput = {
    AND?: ProfileModelScalarWhereWithAggregatesInput | ProfileModelScalarWhereWithAggregatesInput[]
    OR?: ProfileModelScalarWhereWithAggregatesInput[]
    NOT?: ProfileModelScalarWhereWithAggregatesInput | ProfileModelScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"ProfileModel"> | number
    lookingForAJob?: BoolWithAggregatesFilter<"ProfileModel"> | boolean
    lookingForAJobDescription?: StringNullableWithAggregatesFilter<"ProfileModel"> | string | null
    fullName?: StringNullableWithAggregatesFilter<"ProfileModel"> | string | null
    status?: StringNullableWithAggregatesFilter<"ProfileModel"> | string | null
  }

  export type ContactsModelWhereInput = {
    AND?: ContactsModelWhereInput | ContactsModelWhereInput[]
    OR?: ContactsModelWhereInput[]
    NOT?: ContactsModelWhereInput | ContactsModelWhereInput[]
    github?: StringNullableFilter<"ContactsModel"> | string | null
    facebook?: StringNullableFilter<"ContactsModel"> | string | null
    instagram?: StringNullableFilter<"ContactsModel"> | string | null
    twitter?: StringNullableFilter<"ContactsModel"> | string | null
    website?: StringNullableFilter<"ContactsModel"> | string | null
    youtube?: StringNullableFilter<"ContactsModel"> | string | null
    mainLink?: StringNullableFilter<"ContactsModel"> | string | null
    profileId?: IntFilter<"ContactsModel"> | number
    profile?: XOR<ProfileModelRelationFilter, ProfileModelWhereInput>
  }

  export type ContactsModelOrderByWithRelationInput = {
    github?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    youtube?: SortOrderInput | SortOrder
    mainLink?: SortOrderInput | SortOrder
    profileId?: SortOrder
    profile?: ProfileModelOrderByWithRelationInput
  }

  export type ContactsModelWhereUniqueInput = Prisma.AtLeast<{
    profileId?: number
    AND?: ContactsModelWhereInput | ContactsModelWhereInput[]
    OR?: ContactsModelWhereInput[]
    NOT?: ContactsModelWhereInput | ContactsModelWhereInput[]
    github?: StringNullableFilter<"ContactsModel"> | string | null
    facebook?: StringNullableFilter<"ContactsModel"> | string | null
    instagram?: StringNullableFilter<"ContactsModel"> | string | null
    twitter?: StringNullableFilter<"ContactsModel"> | string | null
    website?: StringNullableFilter<"ContactsModel"> | string | null
    youtube?: StringNullableFilter<"ContactsModel"> | string | null
    mainLink?: StringNullableFilter<"ContactsModel"> | string | null
    profile?: XOR<ProfileModelRelationFilter, ProfileModelWhereInput>
  }, "profileId">

  export type ContactsModelOrderByWithAggregationInput = {
    github?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    youtube?: SortOrderInput | SortOrder
    mainLink?: SortOrderInput | SortOrder
    profileId?: SortOrder
    _count?: ContactsModelCountOrderByAggregateInput
    _avg?: ContactsModelAvgOrderByAggregateInput
    _max?: ContactsModelMaxOrderByAggregateInput
    _min?: ContactsModelMinOrderByAggregateInput
    _sum?: ContactsModelSumOrderByAggregateInput
  }

  export type ContactsModelScalarWhereWithAggregatesInput = {
    AND?: ContactsModelScalarWhereWithAggregatesInput | ContactsModelScalarWhereWithAggregatesInput[]
    OR?: ContactsModelScalarWhereWithAggregatesInput[]
    NOT?: ContactsModelScalarWhereWithAggregatesInput | ContactsModelScalarWhereWithAggregatesInput[]
    github?: StringNullableWithAggregatesFilter<"ContactsModel"> | string | null
    facebook?: StringNullableWithAggregatesFilter<"ContactsModel"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"ContactsModel"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"ContactsModel"> | string | null
    website?: StringNullableWithAggregatesFilter<"ContactsModel"> | string | null
    youtube?: StringNullableWithAggregatesFilter<"ContactsModel"> | string | null
    mainLink?: StringNullableWithAggregatesFilter<"ContactsModel"> | string | null
    profileId?: IntWithAggregatesFilter<"ContactsModel"> | number
  }

  export type PhotosModelWhereInput = {
    AND?: PhotosModelWhereInput | PhotosModelWhereInput[]
    OR?: PhotosModelWhereInput[]
    NOT?: PhotosModelWhereInput | PhotosModelWhereInput[]
    small?: StringNullableFilter<"PhotosModel"> | string | null
    large?: StringNullableFilter<"PhotosModel"> | string | null
    profileId?: IntFilter<"PhotosModel"> | number
    profile?: XOR<ProfileModelRelationFilter, ProfileModelWhereInput>
  }

  export type PhotosModelOrderByWithRelationInput = {
    small?: SortOrderInput | SortOrder
    large?: SortOrderInput | SortOrder
    profileId?: SortOrder
    profile?: ProfileModelOrderByWithRelationInput
  }

  export type PhotosModelWhereUniqueInput = Prisma.AtLeast<{
    profileId?: number
    AND?: PhotosModelWhereInput | PhotosModelWhereInput[]
    OR?: PhotosModelWhereInput[]
    NOT?: PhotosModelWhereInput | PhotosModelWhereInput[]
    small?: StringNullableFilter<"PhotosModel"> | string | null
    large?: StringNullableFilter<"PhotosModel"> | string | null
    profile?: XOR<ProfileModelRelationFilter, ProfileModelWhereInput>
  }, "profileId">

  export type PhotosModelOrderByWithAggregationInput = {
    small?: SortOrderInput | SortOrder
    large?: SortOrderInput | SortOrder
    profileId?: SortOrder
    _count?: PhotosModelCountOrderByAggregateInput
    _avg?: PhotosModelAvgOrderByAggregateInput
    _max?: PhotosModelMaxOrderByAggregateInput
    _min?: PhotosModelMinOrderByAggregateInput
    _sum?: PhotosModelSumOrderByAggregateInput
  }

  export type PhotosModelScalarWhereWithAggregatesInput = {
    AND?: PhotosModelScalarWhereWithAggregatesInput | PhotosModelScalarWhereWithAggregatesInput[]
    OR?: PhotosModelScalarWhereWithAggregatesInput[]
    NOT?: PhotosModelScalarWhereWithAggregatesInput | PhotosModelScalarWhereWithAggregatesInput[]
    small?: StringNullableWithAggregatesFilter<"PhotosModel"> | string | null
    large?: StringNullableWithAggregatesFilter<"PhotosModel"> | string | null
    profileId?: IntWithAggregatesFilter<"PhotosModel"> | number
  }

  export type DialogModelWhereInput = {
    AND?: DialogModelWhereInput | DialogModelWhereInput[]
    OR?: DialogModelWhereInput[]
    NOT?: DialogModelWhereInput | DialogModelWhereInput[]
    id?: IntFilter<"DialogModel"> | number
    members?: StringFilter<"DialogModel"> | string
    messages?: MessageModelListRelationFilter
  }

  export type DialogModelOrderByWithRelationInput = {
    id?: SortOrder
    members?: SortOrder
    messages?: MessageModelOrderByRelationAggregateInput
  }

  export type DialogModelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DialogModelWhereInput | DialogModelWhereInput[]
    OR?: DialogModelWhereInput[]
    NOT?: DialogModelWhereInput | DialogModelWhereInput[]
    members?: StringFilter<"DialogModel"> | string
    messages?: MessageModelListRelationFilter
  }, "id">

  export type DialogModelOrderByWithAggregationInput = {
    id?: SortOrder
    members?: SortOrder
    _count?: DialogModelCountOrderByAggregateInput
    _avg?: DialogModelAvgOrderByAggregateInput
    _max?: DialogModelMaxOrderByAggregateInput
    _min?: DialogModelMinOrderByAggregateInput
    _sum?: DialogModelSumOrderByAggregateInput
  }

  export type DialogModelScalarWhereWithAggregatesInput = {
    AND?: DialogModelScalarWhereWithAggregatesInput | DialogModelScalarWhereWithAggregatesInput[]
    OR?: DialogModelScalarWhereWithAggregatesInput[]
    NOT?: DialogModelScalarWhereWithAggregatesInput | DialogModelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DialogModel"> | number
    members?: StringWithAggregatesFilter<"DialogModel"> | string
  }

  export type MessageModelWhereInput = {
    AND?: MessageModelWhereInput | MessageModelWhereInput[]
    OR?: MessageModelWhereInput[]
    NOT?: MessageModelWhereInput | MessageModelWhereInput[]
    id?: IntFilter<"MessageModel"> | number
    createdAt?: DateTimeNullableFilter<"MessageModel"> | Date | string | null
    userId?: IntFilter<"MessageModel"> | number
    text?: StringFilter<"MessageModel"> | string
    dialogId?: IntFilter<"MessageModel"> | number
    dialog?: XOR<DialogModelRelationFilter, DialogModelWhereInput>
  }

  export type MessageModelOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    text?: SortOrder
    dialogId?: SortOrder
    dialog?: DialogModelOrderByWithRelationInput
  }

  export type MessageModelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessageModelWhereInput | MessageModelWhereInput[]
    OR?: MessageModelWhereInput[]
    NOT?: MessageModelWhereInput | MessageModelWhereInput[]
    createdAt?: DateTimeNullableFilter<"MessageModel"> | Date | string | null
    userId?: IntFilter<"MessageModel"> | number
    text?: StringFilter<"MessageModel"> | string
    dialogId?: IntFilter<"MessageModel"> | number
    dialog?: XOR<DialogModelRelationFilter, DialogModelWhereInput>
  }, "id">

  export type MessageModelOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    text?: SortOrder
    dialogId?: SortOrder
    _count?: MessageModelCountOrderByAggregateInput
    _avg?: MessageModelAvgOrderByAggregateInput
    _max?: MessageModelMaxOrderByAggregateInput
    _min?: MessageModelMinOrderByAggregateInput
    _sum?: MessageModelSumOrderByAggregateInput
  }

  export type MessageModelScalarWhereWithAggregatesInput = {
    AND?: MessageModelScalarWhereWithAggregatesInput | MessageModelScalarWhereWithAggregatesInput[]
    OR?: MessageModelScalarWhereWithAggregatesInput[]
    NOT?: MessageModelScalarWhereWithAggregatesInput | MessageModelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MessageModel"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"MessageModel"> | Date | string | null
    userId?: IntWithAggregatesFilter<"MessageModel"> | number
    text?: StringWithAggregatesFilter<"MessageModel"> | string
    dialogId?: IntWithAggregatesFilter<"MessageModel"> | number
  }

  export type UserModelCreateInput = {
    email: string
    login: string
    followed?: string | null
    dialogs?: string | null
    password?: UserPasswordModelCreateNestedOneWithoutUserInput
    profile?: ProfileModelCreateNestedOneWithoutUserInput
  }

  export type UserModelUncheckedCreateInput = {
    id?: number
    email: string
    login: string
    followed?: string | null
    dialogs?: string | null
    password?: UserPasswordModelUncheckedCreateNestedOneWithoutUserInput
    profile?: ProfileModelUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserModelUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    followed?: NullableStringFieldUpdateOperationsInput | string | null
    dialogs?: NullableStringFieldUpdateOperationsInput | string | null
    password?: UserPasswordModelUpdateOneWithoutUserNestedInput
    profile?: ProfileModelUpdateOneWithoutUserNestedInput
  }

  export type UserModelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    followed?: NullableStringFieldUpdateOperationsInput | string | null
    dialogs?: NullableStringFieldUpdateOperationsInput | string | null
    password?: UserPasswordModelUncheckedUpdateOneWithoutUserNestedInput
    profile?: ProfileModelUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserModelUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    followed?: NullableStringFieldUpdateOperationsInput | string | null
    dialogs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserModelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    followed?: NullableStringFieldUpdateOperationsInput | string | null
    dialogs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPasswordModelCreateInput = {
    password: string
    user: UserModelCreateNestedOneWithoutPasswordInput
  }

  export type UserPasswordModelUncheckedCreateInput = {
    userId: number
    password: string
  }

  export type UserPasswordModelUpdateInput = {
    password?: StringFieldUpdateOperationsInput | string
    user?: UserModelUpdateOneRequiredWithoutPasswordNestedInput
  }

  export type UserPasswordModelUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserPasswordModelUpdateManyMutationInput = {
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserPasswordModelUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileModelCreateInput = {
    lookingForAJob: boolean
    lookingForAJobDescription?: string | null
    fullName?: string | null
    status?: string | null
    user: UserModelCreateNestedOneWithoutProfileInput
    contacts?: ContactsModelCreateNestedOneWithoutProfileInput
    photos?: PhotosModelCreateNestedOneWithoutProfileInput
  }

  export type ProfileModelUncheckedCreateInput = {
    userId: number
    lookingForAJob: boolean
    lookingForAJobDescription?: string | null
    fullName?: string | null
    status?: string | null
    contacts?: ContactsModelUncheckedCreateNestedOneWithoutProfileInput
    photos?: PhotosModelUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileModelUpdateInput = {
    lookingForAJob?: BoolFieldUpdateOperationsInput | boolean
    lookingForAJobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserModelUpdateOneRequiredWithoutProfileNestedInput
    contacts?: ContactsModelUpdateOneWithoutProfileNestedInput
    photos?: PhotosModelUpdateOneWithoutProfileNestedInput
  }

  export type ProfileModelUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    lookingForAJob?: BoolFieldUpdateOperationsInput | boolean
    lookingForAJobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: ContactsModelUncheckedUpdateOneWithoutProfileNestedInput
    photos?: PhotosModelUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type ProfileModelUpdateManyMutationInput = {
    lookingForAJob?: BoolFieldUpdateOperationsInput | boolean
    lookingForAJobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileModelUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    lookingForAJob?: BoolFieldUpdateOperationsInput | boolean
    lookingForAJobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactsModelCreateInput = {
    github?: string | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    website?: string | null
    youtube?: string | null
    mainLink?: string | null
    profile: ProfileModelCreateNestedOneWithoutContactsInput
  }

  export type ContactsModelUncheckedCreateInput = {
    github?: string | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    website?: string | null
    youtube?: string | null
    mainLink?: string | null
    profileId: number
  }

  export type ContactsModelUpdateInput = {
    github?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    mainLink?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileModelUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactsModelUncheckedUpdateInput = {
    github?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    mainLink?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: IntFieldUpdateOperationsInput | number
  }

  export type ContactsModelUpdateManyMutationInput = {
    github?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    mainLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactsModelUncheckedUpdateManyInput = {
    github?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    mainLink?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: IntFieldUpdateOperationsInput | number
  }

  export type PhotosModelCreateInput = {
    small?: string | null
    large?: string | null
    profile: ProfileModelCreateNestedOneWithoutPhotosInput
  }

  export type PhotosModelUncheckedCreateInput = {
    small?: string | null
    large?: string | null
    profileId: number
  }

  export type PhotosModelUpdateInput = {
    small?: NullableStringFieldUpdateOperationsInput | string | null
    large?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileModelUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type PhotosModelUncheckedUpdateInput = {
    small?: NullableStringFieldUpdateOperationsInput | string | null
    large?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: IntFieldUpdateOperationsInput | number
  }

  export type PhotosModelUpdateManyMutationInput = {
    small?: NullableStringFieldUpdateOperationsInput | string | null
    large?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhotosModelUncheckedUpdateManyInput = {
    small?: NullableStringFieldUpdateOperationsInput | string | null
    large?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: IntFieldUpdateOperationsInput | number
  }

  export type DialogModelCreateInput = {
    members: string
    messages?: MessageModelCreateNestedManyWithoutDialogInput
  }

  export type DialogModelUncheckedCreateInput = {
    id?: number
    members: string
    messages?: MessageModelUncheckedCreateNestedManyWithoutDialogInput
  }

  export type DialogModelUpdateInput = {
    members?: StringFieldUpdateOperationsInput | string
    messages?: MessageModelUpdateManyWithoutDialogNestedInput
  }

  export type DialogModelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    members?: StringFieldUpdateOperationsInput | string
    messages?: MessageModelUncheckedUpdateManyWithoutDialogNestedInput
  }

  export type DialogModelUpdateManyMutationInput = {
    members?: StringFieldUpdateOperationsInput | string
  }

  export type DialogModelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    members?: StringFieldUpdateOperationsInput | string
  }

  export type MessageModelCreateInput = {
    createdAt?: Date | string | null
    userId: number
    text: string
    dialog: DialogModelCreateNestedOneWithoutMessagesInput
  }

  export type MessageModelUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string | null
    userId: number
    text: string
    dialogId: number
  }

  export type MessageModelUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    dialog?: DialogModelUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageModelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    dialogId?: IntFieldUpdateOperationsInput | number
  }

  export type MessageModelUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type MessageModelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    dialogId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserPasswordModelNullableRelationFilter = {
    is?: UserPasswordModelWhereInput | null
    isNot?: UserPasswordModelWhereInput | null
  }

  export type ProfileModelNullableRelationFilter = {
    is?: ProfileModelWhereInput | null
    isNot?: ProfileModelWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserModelCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    login?: SortOrder
    followed?: SortOrder
    dialogs?: SortOrder
  }

  export type UserModelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserModelMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    login?: SortOrder
    followed?: SortOrder
    dialogs?: SortOrder
  }

  export type UserModelMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    login?: SortOrder
    followed?: SortOrder
    dialogs?: SortOrder
  }

  export type UserModelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UserModelRelationFilter = {
    is?: UserModelWhereInput
    isNot?: UserModelWhereInput
  }

  export type UserPasswordModelCountOrderByAggregateInput = {
    userId?: SortOrder
    password?: SortOrder
  }

  export type UserPasswordModelAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserPasswordModelMaxOrderByAggregateInput = {
    userId?: SortOrder
    password?: SortOrder
  }

  export type UserPasswordModelMinOrderByAggregateInput = {
    userId?: SortOrder
    password?: SortOrder
  }

  export type UserPasswordModelSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ContactsModelNullableRelationFilter = {
    is?: ContactsModelWhereInput | null
    isNot?: ContactsModelWhereInput | null
  }

  export type PhotosModelNullableRelationFilter = {
    is?: PhotosModelWhereInput | null
    isNot?: PhotosModelWhereInput | null
  }

  export type ProfileModelCountOrderByAggregateInput = {
    userId?: SortOrder
    lookingForAJob?: SortOrder
    lookingForAJobDescription?: SortOrder
    fullName?: SortOrder
    status?: SortOrder
  }

  export type ProfileModelAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type ProfileModelMaxOrderByAggregateInput = {
    userId?: SortOrder
    lookingForAJob?: SortOrder
    lookingForAJobDescription?: SortOrder
    fullName?: SortOrder
    status?: SortOrder
  }

  export type ProfileModelMinOrderByAggregateInput = {
    userId?: SortOrder
    lookingForAJob?: SortOrder
    lookingForAJobDescription?: SortOrder
    fullName?: SortOrder
    status?: SortOrder
  }

  export type ProfileModelSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ProfileModelRelationFilter = {
    is?: ProfileModelWhereInput
    isNot?: ProfileModelWhereInput
  }

  export type ContactsModelCountOrderByAggregateInput = {
    github?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    twitter?: SortOrder
    website?: SortOrder
    youtube?: SortOrder
    mainLink?: SortOrder
    profileId?: SortOrder
  }

  export type ContactsModelAvgOrderByAggregateInput = {
    profileId?: SortOrder
  }

  export type ContactsModelMaxOrderByAggregateInput = {
    github?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    twitter?: SortOrder
    website?: SortOrder
    youtube?: SortOrder
    mainLink?: SortOrder
    profileId?: SortOrder
  }

  export type ContactsModelMinOrderByAggregateInput = {
    github?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    twitter?: SortOrder
    website?: SortOrder
    youtube?: SortOrder
    mainLink?: SortOrder
    profileId?: SortOrder
  }

  export type ContactsModelSumOrderByAggregateInput = {
    profileId?: SortOrder
  }

  export type PhotosModelCountOrderByAggregateInput = {
    small?: SortOrder
    large?: SortOrder
    profileId?: SortOrder
  }

  export type PhotosModelAvgOrderByAggregateInput = {
    profileId?: SortOrder
  }

  export type PhotosModelMaxOrderByAggregateInput = {
    small?: SortOrder
    large?: SortOrder
    profileId?: SortOrder
  }

  export type PhotosModelMinOrderByAggregateInput = {
    small?: SortOrder
    large?: SortOrder
    profileId?: SortOrder
  }

  export type PhotosModelSumOrderByAggregateInput = {
    profileId?: SortOrder
  }

  export type MessageModelListRelationFilter = {
    every?: MessageModelWhereInput
    some?: MessageModelWhereInput
    none?: MessageModelWhereInput
  }

  export type MessageModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DialogModelCountOrderByAggregateInput = {
    id?: SortOrder
    members?: SortOrder
  }

  export type DialogModelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DialogModelMaxOrderByAggregateInput = {
    id?: SortOrder
    members?: SortOrder
  }

  export type DialogModelMinOrderByAggregateInput = {
    id?: SortOrder
    members?: SortOrder
  }

  export type DialogModelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DialogModelRelationFilter = {
    is?: DialogModelWhereInput
    isNot?: DialogModelWhereInput
  }

  export type MessageModelCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    dialogId?: SortOrder
  }

  export type MessageModelAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dialogId?: SortOrder
  }

  export type MessageModelMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    dialogId?: SortOrder
  }

  export type MessageModelMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    dialogId?: SortOrder
  }

  export type MessageModelSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dialogId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserPasswordModelCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPasswordModelCreateWithoutUserInput, UserPasswordModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPasswordModelCreateOrConnectWithoutUserInput
    connect?: UserPasswordModelWhereUniqueInput
  }

  export type ProfileModelCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileModelCreateWithoutUserInput, ProfileModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileModelCreateOrConnectWithoutUserInput
    connect?: ProfileModelWhereUniqueInput
  }

  export type UserPasswordModelUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPasswordModelCreateWithoutUserInput, UserPasswordModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPasswordModelCreateOrConnectWithoutUserInput
    connect?: UserPasswordModelWhereUniqueInput
  }

  export type ProfileModelUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileModelCreateWithoutUserInput, ProfileModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileModelCreateOrConnectWithoutUserInput
    connect?: ProfileModelWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserPasswordModelUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPasswordModelCreateWithoutUserInput, UserPasswordModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPasswordModelCreateOrConnectWithoutUserInput
    upsert?: UserPasswordModelUpsertWithoutUserInput
    disconnect?: UserPasswordModelWhereInput | boolean
    delete?: UserPasswordModelWhereInput | boolean
    connect?: UserPasswordModelWhereUniqueInput
    update?: XOR<XOR<UserPasswordModelUpdateToOneWithWhereWithoutUserInput, UserPasswordModelUpdateWithoutUserInput>, UserPasswordModelUncheckedUpdateWithoutUserInput>
  }

  export type ProfileModelUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileModelCreateWithoutUserInput, ProfileModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileModelCreateOrConnectWithoutUserInput
    upsert?: ProfileModelUpsertWithoutUserInput
    disconnect?: ProfileModelWhereInput | boolean
    delete?: ProfileModelWhereInput | boolean
    connect?: ProfileModelWhereUniqueInput
    update?: XOR<XOR<ProfileModelUpdateToOneWithWhereWithoutUserInput, ProfileModelUpdateWithoutUserInput>, ProfileModelUncheckedUpdateWithoutUserInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserPasswordModelUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPasswordModelCreateWithoutUserInput, UserPasswordModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPasswordModelCreateOrConnectWithoutUserInput
    upsert?: UserPasswordModelUpsertWithoutUserInput
    disconnect?: UserPasswordModelWhereInput | boolean
    delete?: UserPasswordModelWhereInput | boolean
    connect?: UserPasswordModelWhereUniqueInput
    update?: XOR<XOR<UserPasswordModelUpdateToOneWithWhereWithoutUserInput, UserPasswordModelUpdateWithoutUserInput>, UserPasswordModelUncheckedUpdateWithoutUserInput>
  }

  export type ProfileModelUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileModelCreateWithoutUserInput, ProfileModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileModelCreateOrConnectWithoutUserInput
    upsert?: ProfileModelUpsertWithoutUserInput
    disconnect?: ProfileModelWhereInput | boolean
    delete?: ProfileModelWhereInput | boolean
    connect?: ProfileModelWhereUniqueInput
    update?: XOR<XOR<ProfileModelUpdateToOneWithWhereWithoutUserInput, ProfileModelUpdateWithoutUserInput>, ProfileModelUncheckedUpdateWithoutUserInput>
  }

  export type UserModelCreateNestedOneWithoutPasswordInput = {
    create?: XOR<UserModelCreateWithoutPasswordInput, UserModelUncheckedCreateWithoutPasswordInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutPasswordInput
    connect?: UserModelWhereUniqueInput
  }

  export type UserModelUpdateOneRequiredWithoutPasswordNestedInput = {
    create?: XOR<UserModelCreateWithoutPasswordInput, UserModelUncheckedCreateWithoutPasswordInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutPasswordInput
    upsert?: UserModelUpsertWithoutPasswordInput
    connect?: UserModelWhereUniqueInput
    update?: XOR<XOR<UserModelUpdateToOneWithWhereWithoutPasswordInput, UserModelUpdateWithoutPasswordInput>, UserModelUncheckedUpdateWithoutPasswordInput>
  }

  export type UserModelCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserModelCreateWithoutProfileInput, UserModelUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutProfileInput
    connect?: UserModelWhereUniqueInput
  }

  export type ContactsModelCreateNestedOneWithoutProfileInput = {
    create?: XOR<ContactsModelCreateWithoutProfileInput, ContactsModelUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ContactsModelCreateOrConnectWithoutProfileInput
    connect?: ContactsModelWhereUniqueInput
  }

  export type PhotosModelCreateNestedOneWithoutProfileInput = {
    create?: XOR<PhotosModelCreateWithoutProfileInput, PhotosModelUncheckedCreateWithoutProfileInput>
    connectOrCreate?: PhotosModelCreateOrConnectWithoutProfileInput
    connect?: PhotosModelWhereUniqueInput
  }

  export type ContactsModelUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<ContactsModelCreateWithoutProfileInput, ContactsModelUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ContactsModelCreateOrConnectWithoutProfileInput
    connect?: ContactsModelWhereUniqueInput
  }

  export type PhotosModelUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<PhotosModelCreateWithoutProfileInput, PhotosModelUncheckedCreateWithoutProfileInput>
    connectOrCreate?: PhotosModelCreateOrConnectWithoutProfileInput
    connect?: PhotosModelWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserModelUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserModelCreateWithoutProfileInput, UserModelUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutProfileInput
    upsert?: UserModelUpsertWithoutProfileInput
    connect?: UserModelWhereUniqueInput
    update?: XOR<XOR<UserModelUpdateToOneWithWhereWithoutProfileInput, UserModelUpdateWithoutProfileInput>, UserModelUncheckedUpdateWithoutProfileInput>
  }

  export type ContactsModelUpdateOneWithoutProfileNestedInput = {
    create?: XOR<ContactsModelCreateWithoutProfileInput, ContactsModelUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ContactsModelCreateOrConnectWithoutProfileInput
    upsert?: ContactsModelUpsertWithoutProfileInput
    disconnect?: ContactsModelWhereInput | boolean
    delete?: ContactsModelWhereInput | boolean
    connect?: ContactsModelWhereUniqueInput
    update?: XOR<XOR<ContactsModelUpdateToOneWithWhereWithoutProfileInput, ContactsModelUpdateWithoutProfileInput>, ContactsModelUncheckedUpdateWithoutProfileInput>
  }

  export type PhotosModelUpdateOneWithoutProfileNestedInput = {
    create?: XOR<PhotosModelCreateWithoutProfileInput, PhotosModelUncheckedCreateWithoutProfileInput>
    connectOrCreate?: PhotosModelCreateOrConnectWithoutProfileInput
    upsert?: PhotosModelUpsertWithoutProfileInput
    disconnect?: PhotosModelWhereInput | boolean
    delete?: PhotosModelWhereInput | boolean
    connect?: PhotosModelWhereUniqueInput
    update?: XOR<XOR<PhotosModelUpdateToOneWithWhereWithoutProfileInput, PhotosModelUpdateWithoutProfileInput>, PhotosModelUncheckedUpdateWithoutProfileInput>
  }

  export type ContactsModelUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<ContactsModelCreateWithoutProfileInput, ContactsModelUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ContactsModelCreateOrConnectWithoutProfileInput
    upsert?: ContactsModelUpsertWithoutProfileInput
    disconnect?: ContactsModelWhereInput | boolean
    delete?: ContactsModelWhereInput | boolean
    connect?: ContactsModelWhereUniqueInput
    update?: XOR<XOR<ContactsModelUpdateToOneWithWhereWithoutProfileInput, ContactsModelUpdateWithoutProfileInput>, ContactsModelUncheckedUpdateWithoutProfileInput>
  }

  export type PhotosModelUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<PhotosModelCreateWithoutProfileInput, PhotosModelUncheckedCreateWithoutProfileInput>
    connectOrCreate?: PhotosModelCreateOrConnectWithoutProfileInput
    upsert?: PhotosModelUpsertWithoutProfileInput
    disconnect?: PhotosModelWhereInput | boolean
    delete?: PhotosModelWhereInput | boolean
    connect?: PhotosModelWhereUniqueInput
    update?: XOR<XOR<PhotosModelUpdateToOneWithWhereWithoutProfileInput, PhotosModelUpdateWithoutProfileInput>, PhotosModelUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileModelCreateNestedOneWithoutContactsInput = {
    create?: XOR<ProfileModelCreateWithoutContactsInput, ProfileModelUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ProfileModelCreateOrConnectWithoutContactsInput
    connect?: ProfileModelWhereUniqueInput
  }

  export type ProfileModelUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<ProfileModelCreateWithoutContactsInput, ProfileModelUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ProfileModelCreateOrConnectWithoutContactsInput
    upsert?: ProfileModelUpsertWithoutContactsInput
    connect?: ProfileModelWhereUniqueInput
    update?: XOR<XOR<ProfileModelUpdateToOneWithWhereWithoutContactsInput, ProfileModelUpdateWithoutContactsInput>, ProfileModelUncheckedUpdateWithoutContactsInput>
  }

  export type ProfileModelCreateNestedOneWithoutPhotosInput = {
    create?: XOR<ProfileModelCreateWithoutPhotosInput, ProfileModelUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ProfileModelCreateOrConnectWithoutPhotosInput
    connect?: ProfileModelWhereUniqueInput
  }

  export type ProfileModelUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<ProfileModelCreateWithoutPhotosInput, ProfileModelUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ProfileModelCreateOrConnectWithoutPhotosInput
    upsert?: ProfileModelUpsertWithoutPhotosInput
    connect?: ProfileModelWhereUniqueInput
    update?: XOR<XOR<ProfileModelUpdateToOneWithWhereWithoutPhotosInput, ProfileModelUpdateWithoutPhotosInput>, ProfileModelUncheckedUpdateWithoutPhotosInput>
  }

  export type MessageModelCreateNestedManyWithoutDialogInput = {
    create?: XOR<MessageModelCreateWithoutDialogInput, MessageModelUncheckedCreateWithoutDialogInput> | MessageModelCreateWithoutDialogInput[] | MessageModelUncheckedCreateWithoutDialogInput[]
    connectOrCreate?: MessageModelCreateOrConnectWithoutDialogInput | MessageModelCreateOrConnectWithoutDialogInput[]
    connect?: MessageModelWhereUniqueInput | MessageModelWhereUniqueInput[]
  }

  export type MessageModelUncheckedCreateNestedManyWithoutDialogInput = {
    create?: XOR<MessageModelCreateWithoutDialogInput, MessageModelUncheckedCreateWithoutDialogInput> | MessageModelCreateWithoutDialogInput[] | MessageModelUncheckedCreateWithoutDialogInput[]
    connectOrCreate?: MessageModelCreateOrConnectWithoutDialogInput | MessageModelCreateOrConnectWithoutDialogInput[]
    connect?: MessageModelWhereUniqueInput | MessageModelWhereUniqueInput[]
  }

  export type MessageModelUpdateManyWithoutDialogNestedInput = {
    create?: XOR<MessageModelCreateWithoutDialogInput, MessageModelUncheckedCreateWithoutDialogInput> | MessageModelCreateWithoutDialogInput[] | MessageModelUncheckedCreateWithoutDialogInput[]
    connectOrCreate?: MessageModelCreateOrConnectWithoutDialogInput | MessageModelCreateOrConnectWithoutDialogInput[]
    upsert?: MessageModelUpsertWithWhereUniqueWithoutDialogInput | MessageModelUpsertWithWhereUniqueWithoutDialogInput[]
    set?: MessageModelWhereUniqueInput | MessageModelWhereUniqueInput[]
    disconnect?: MessageModelWhereUniqueInput | MessageModelWhereUniqueInput[]
    delete?: MessageModelWhereUniqueInput | MessageModelWhereUniqueInput[]
    connect?: MessageModelWhereUniqueInput | MessageModelWhereUniqueInput[]
    update?: MessageModelUpdateWithWhereUniqueWithoutDialogInput | MessageModelUpdateWithWhereUniqueWithoutDialogInput[]
    updateMany?: MessageModelUpdateManyWithWhereWithoutDialogInput | MessageModelUpdateManyWithWhereWithoutDialogInput[]
    deleteMany?: MessageModelScalarWhereInput | MessageModelScalarWhereInput[]
  }

  export type MessageModelUncheckedUpdateManyWithoutDialogNestedInput = {
    create?: XOR<MessageModelCreateWithoutDialogInput, MessageModelUncheckedCreateWithoutDialogInput> | MessageModelCreateWithoutDialogInput[] | MessageModelUncheckedCreateWithoutDialogInput[]
    connectOrCreate?: MessageModelCreateOrConnectWithoutDialogInput | MessageModelCreateOrConnectWithoutDialogInput[]
    upsert?: MessageModelUpsertWithWhereUniqueWithoutDialogInput | MessageModelUpsertWithWhereUniqueWithoutDialogInput[]
    set?: MessageModelWhereUniqueInput | MessageModelWhereUniqueInput[]
    disconnect?: MessageModelWhereUniqueInput | MessageModelWhereUniqueInput[]
    delete?: MessageModelWhereUniqueInput | MessageModelWhereUniqueInput[]
    connect?: MessageModelWhereUniqueInput | MessageModelWhereUniqueInput[]
    update?: MessageModelUpdateWithWhereUniqueWithoutDialogInput | MessageModelUpdateWithWhereUniqueWithoutDialogInput[]
    updateMany?: MessageModelUpdateManyWithWhereWithoutDialogInput | MessageModelUpdateManyWithWhereWithoutDialogInput[]
    deleteMany?: MessageModelScalarWhereInput | MessageModelScalarWhereInput[]
  }

  export type DialogModelCreateNestedOneWithoutMessagesInput = {
    create?: XOR<DialogModelCreateWithoutMessagesInput, DialogModelUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: DialogModelCreateOrConnectWithoutMessagesInput
    connect?: DialogModelWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DialogModelUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<DialogModelCreateWithoutMessagesInput, DialogModelUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: DialogModelCreateOrConnectWithoutMessagesInput
    upsert?: DialogModelUpsertWithoutMessagesInput
    connect?: DialogModelWhereUniqueInput
    update?: XOR<XOR<DialogModelUpdateToOneWithWhereWithoutMessagesInput, DialogModelUpdateWithoutMessagesInput>, DialogModelUncheckedUpdateWithoutMessagesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserPasswordModelCreateWithoutUserInput = {
    password: string
  }

  export type UserPasswordModelUncheckedCreateWithoutUserInput = {
    password: string
  }

  export type UserPasswordModelCreateOrConnectWithoutUserInput = {
    where: UserPasswordModelWhereUniqueInput
    create: XOR<UserPasswordModelCreateWithoutUserInput, UserPasswordModelUncheckedCreateWithoutUserInput>
  }

  export type ProfileModelCreateWithoutUserInput = {
    lookingForAJob: boolean
    lookingForAJobDescription?: string | null
    fullName?: string | null
    status?: string | null
    contacts?: ContactsModelCreateNestedOneWithoutProfileInput
    photos?: PhotosModelCreateNestedOneWithoutProfileInput
  }

  export type ProfileModelUncheckedCreateWithoutUserInput = {
    lookingForAJob: boolean
    lookingForAJobDescription?: string | null
    fullName?: string | null
    status?: string | null
    contacts?: ContactsModelUncheckedCreateNestedOneWithoutProfileInput
    photos?: PhotosModelUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileModelCreateOrConnectWithoutUserInput = {
    where: ProfileModelWhereUniqueInput
    create: XOR<ProfileModelCreateWithoutUserInput, ProfileModelUncheckedCreateWithoutUserInput>
  }

  export type UserPasswordModelUpsertWithoutUserInput = {
    update: XOR<UserPasswordModelUpdateWithoutUserInput, UserPasswordModelUncheckedUpdateWithoutUserInput>
    create: XOR<UserPasswordModelCreateWithoutUserInput, UserPasswordModelUncheckedCreateWithoutUserInput>
    where?: UserPasswordModelWhereInput
  }

  export type UserPasswordModelUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPasswordModelWhereInput
    data: XOR<UserPasswordModelUpdateWithoutUserInput, UserPasswordModelUncheckedUpdateWithoutUserInput>
  }

  export type UserPasswordModelUpdateWithoutUserInput = {
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserPasswordModelUncheckedUpdateWithoutUserInput = {
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileModelUpsertWithoutUserInput = {
    update: XOR<ProfileModelUpdateWithoutUserInput, ProfileModelUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileModelCreateWithoutUserInput, ProfileModelUncheckedCreateWithoutUserInput>
    where?: ProfileModelWhereInput
  }

  export type ProfileModelUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileModelWhereInput
    data: XOR<ProfileModelUpdateWithoutUserInput, ProfileModelUncheckedUpdateWithoutUserInput>
  }

  export type ProfileModelUpdateWithoutUserInput = {
    lookingForAJob?: BoolFieldUpdateOperationsInput | boolean
    lookingForAJobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: ContactsModelUpdateOneWithoutProfileNestedInput
    photos?: PhotosModelUpdateOneWithoutProfileNestedInput
  }

  export type ProfileModelUncheckedUpdateWithoutUserInput = {
    lookingForAJob?: BoolFieldUpdateOperationsInput | boolean
    lookingForAJobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: ContactsModelUncheckedUpdateOneWithoutProfileNestedInput
    photos?: PhotosModelUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type UserModelCreateWithoutPasswordInput = {
    email: string
    login: string
    followed?: string | null
    dialogs?: string | null
    profile?: ProfileModelCreateNestedOneWithoutUserInput
  }

  export type UserModelUncheckedCreateWithoutPasswordInput = {
    id?: number
    email: string
    login: string
    followed?: string | null
    dialogs?: string | null
    profile?: ProfileModelUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserModelCreateOrConnectWithoutPasswordInput = {
    where: UserModelWhereUniqueInput
    create: XOR<UserModelCreateWithoutPasswordInput, UserModelUncheckedCreateWithoutPasswordInput>
  }

  export type UserModelUpsertWithoutPasswordInput = {
    update: XOR<UserModelUpdateWithoutPasswordInput, UserModelUncheckedUpdateWithoutPasswordInput>
    create: XOR<UserModelCreateWithoutPasswordInput, UserModelUncheckedCreateWithoutPasswordInput>
    where?: UserModelWhereInput
  }

  export type UserModelUpdateToOneWithWhereWithoutPasswordInput = {
    where?: UserModelWhereInput
    data: XOR<UserModelUpdateWithoutPasswordInput, UserModelUncheckedUpdateWithoutPasswordInput>
  }

  export type UserModelUpdateWithoutPasswordInput = {
    email?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    followed?: NullableStringFieldUpdateOperationsInput | string | null
    dialogs?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileModelUpdateOneWithoutUserNestedInput
  }

  export type UserModelUncheckedUpdateWithoutPasswordInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    followed?: NullableStringFieldUpdateOperationsInput | string | null
    dialogs?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileModelUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserModelCreateWithoutProfileInput = {
    email: string
    login: string
    followed?: string | null
    dialogs?: string | null
    password?: UserPasswordModelCreateNestedOneWithoutUserInput
  }

  export type UserModelUncheckedCreateWithoutProfileInput = {
    id?: number
    email: string
    login: string
    followed?: string | null
    dialogs?: string | null
    password?: UserPasswordModelUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserModelCreateOrConnectWithoutProfileInput = {
    where: UserModelWhereUniqueInput
    create: XOR<UserModelCreateWithoutProfileInput, UserModelUncheckedCreateWithoutProfileInput>
  }

  export type ContactsModelCreateWithoutProfileInput = {
    github?: string | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    website?: string | null
    youtube?: string | null
    mainLink?: string | null
  }

  export type ContactsModelUncheckedCreateWithoutProfileInput = {
    github?: string | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    website?: string | null
    youtube?: string | null
    mainLink?: string | null
  }

  export type ContactsModelCreateOrConnectWithoutProfileInput = {
    where: ContactsModelWhereUniqueInput
    create: XOR<ContactsModelCreateWithoutProfileInput, ContactsModelUncheckedCreateWithoutProfileInput>
  }

  export type PhotosModelCreateWithoutProfileInput = {
    small?: string | null
    large?: string | null
  }

  export type PhotosModelUncheckedCreateWithoutProfileInput = {
    small?: string | null
    large?: string | null
  }

  export type PhotosModelCreateOrConnectWithoutProfileInput = {
    where: PhotosModelWhereUniqueInput
    create: XOR<PhotosModelCreateWithoutProfileInput, PhotosModelUncheckedCreateWithoutProfileInput>
  }

  export type UserModelUpsertWithoutProfileInput = {
    update: XOR<UserModelUpdateWithoutProfileInput, UserModelUncheckedUpdateWithoutProfileInput>
    create: XOR<UserModelCreateWithoutProfileInput, UserModelUncheckedCreateWithoutProfileInput>
    where?: UserModelWhereInput
  }

  export type UserModelUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserModelWhereInput
    data: XOR<UserModelUpdateWithoutProfileInput, UserModelUncheckedUpdateWithoutProfileInput>
  }

  export type UserModelUpdateWithoutProfileInput = {
    email?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    followed?: NullableStringFieldUpdateOperationsInput | string | null
    dialogs?: NullableStringFieldUpdateOperationsInput | string | null
    password?: UserPasswordModelUpdateOneWithoutUserNestedInput
  }

  export type UserModelUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    followed?: NullableStringFieldUpdateOperationsInput | string | null
    dialogs?: NullableStringFieldUpdateOperationsInput | string | null
    password?: UserPasswordModelUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ContactsModelUpsertWithoutProfileInput = {
    update: XOR<ContactsModelUpdateWithoutProfileInput, ContactsModelUncheckedUpdateWithoutProfileInput>
    create: XOR<ContactsModelCreateWithoutProfileInput, ContactsModelUncheckedCreateWithoutProfileInput>
    where?: ContactsModelWhereInput
  }

  export type ContactsModelUpdateToOneWithWhereWithoutProfileInput = {
    where?: ContactsModelWhereInput
    data: XOR<ContactsModelUpdateWithoutProfileInput, ContactsModelUncheckedUpdateWithoutProfileInput>
  }

  export type ContactsModelUpdateWithoutProfileInput = {
    github?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    mainLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactsModelUncheckedUpdateWithoutProfileInput = {
    github?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    mainLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhotosModelUpsertWithoutProfileInput = {
    update: XOR<PhotosModelUpdateWithoutProfileInput, PhotosModelUncheckedUpdateWithoutProfileInput>
    create: XOR<PhotosModelCreateWithoutProfileInput, PhotosModelUncheckedCreateWithoutProfileInput>
    where?: PhotosModelWhereInput
  }

  export type PhotosModelUpdateToOneWithWhereWithoutProfileInput = {
    where?: PhotosModelWhereInput
    data: XOR<PhotosModelUpdateWithoutProfileInput, PhotosModelUncheckedUpdateWithoutProfileInput>
  }

  export type PhotosModelUpdateWithoutProfileInput = {
    small?: NullableStringFieldUpdateOperationsInput | string | null
    large?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhotosModelUncheckedUpdateWithoutProfileInput = {
    small?: NullableStringFieldUpdateOperationsInput | string | null
    large?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileModelCreateWithoutContactsInput = {
    lookingForAJob: boolean
    lookingForAJobDescription?: string | null
    fullName?: string | null
    status?: string | null
    user: UserModelCreateNestedOneWithoutProfileInput
    photos?: PhotosModelCreateNestedOneWithoutProfileInput
  }

  export type ProfileModelUncheckedCreateWithoutContactsInput = {
    userId: number
    lookingForAJob: boolean
    lookingForAJobDescription?: string | null
    fullName?: string | null
    status?: string | null
    photos?: PhotosModelUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileModelCreateOrConnectWithoutContactsInput = {
    where: ProfileModelWhereUniqueInput
    create: XOR<ProfileModelCreateWithoutContactsInput, ProfileModelUncheckedCreateWithoutContactsInput>
  }

  export type ProfileModelUpsertWithoutContactsInput = {
    update: XOR<ProfileModelUpdateWithoutContactsInput, ProfileModelUncheckedUpdateWithoutContactsInput>
    create: XOR<ProfileModelCreateWithoutContactsInput, ProfileModelUncheckedCreateWithoutContactsInput>
    where?: ProfileModelWhereInput
  }

  export type ProfileModelUpdateToOneWithWhereWithoutContactsInput = {
    where?: ProfileModelWhereInput
    data: XOR<ProfileModelUpdateWithoutContactsInput, ProfileModelUncheckedUpdateWithoutContactsInput>
  }

  export type ProfileModelUpdateWithoutContactsInput = {
    lookingForAJob?: BoolFieldUpdateOperationsInput | boolean
    lookingForAJobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserModelUpdateOneRequiredWithoutProfileNestedInput
    photos?: PhotosModelUpdateOneWithoutProfileNestedInput
  }

  export type ProfileModelUncheckedUpdateWithoutContactsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    lookingForAJob?: BoolFieldUpdateOperationsInput | boolean
    lookingForAJobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: PhotosModelUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type ProfileModelCreateWithoutPhotosInput = {
    lookingForAJob: boolean
    lookingForAJobDescription?: string | null
    fullName?: string | null
    status?: string | null
    user: UserModelCreateNestedOneWithoutProfileInput
    contacts?: ContactsModelCreateNestedOneWithoutProfileInput
  }

  export type ProfileModelUncheckedCreateWithoutPhotosInput = {
    userId: number
    lookingForAJob: boolean
    lookingForAJobDescription?: string | null
    fullName?: string | null
    status?: string | null
    contacts?: ContactsModelUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileModelCreateOrConnectWithoutPhotosInput = {
    where: ProfileModelWhereUniqueInput
    create: XOR<ProfileModelCreateWithoutPhotosInput, ProfileModelUncheckedCreateWithoutPhotosInput>
  }

  export type ProfileModelUpsertWithoutPhotosInput = {
    update: XOR<ProfileModelUpdateWithoutPhotosInput, ProfileModelUncheckedUpdateWithoutPhotosInput>
    create: XOR<ProfileModelCreateWithoutPhotosInput, ProfileModelUncheckedCreateWithoutPhotosInput>
    where?: ProfileModelWhereInput
  }

  export type ProfileModelUpdateToOneWithWhereWithoutPhotosInput = {
    where?: ProfileModelWhereInput
    data: XOR<ProfileModelUpdateWithoutPhotosInput, ProfileModelUncheckedUpdateWithoutPhotosInput>
  }

  export type ProfileModelUpdateWithoutPhotosInput = {
    lookingForAJob?: BoolFieldUpdateOperationsInput | boolean
    lookingForAJobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserModelUpdateOneRequiredWithoutProfileNestedInput
    contacts?: ContactsModelUpdateOneWithoutProfileNestedInput
  }

  export type ProfileModelUncheckedUpdateWithoutPhotosInput = {
    userId?: IntFieldUpdateOperationsInput | number
    lookingForAJob?: BoolFieldUpdateOperationsInput | boolean
    lookingForAJobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: ContactsModelUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type MessageModelCreateWithoutDialogInput = {
    createdAt?: Date | string | null
    userId: number
    text: string
  }

  export type MessageModelUncheckedCreateWithoutDialogInput = {
    id?: number
    createdAt?: Date | string | null
    userId: number
    text: string
  }

  export type MessageModelCreateOrConnectWithoutDialogInput = {
    where: MessageModelWhereUniqueInput
    create: XOR<MessageModelCreateWithoutDialogInput, MessageModelUncheckedCreateWithoutDialogInput>
  }

  export type MessageModelUpsertWithWhereUniqueWithoutDialogInput = {
    where: MessageModelWhereUniqueInput
    update: XOR<MessageModelUpdateWithoutDialogInput, MessageModelUncheckedUpdateWithoutDialogInput>
    create: XOR<MessageModelCreateWithoutDialogInput, MessageModelUncheckedCreateWithoutDialogInput>
  }

  export type MessageModelUpdateWithWhereUniqueWithoutDialogInput = {
    where: MessageModelWhereUniqueInput
    data: XOR<MessageModelUpdateWithoutDialogInput, MessageModelUncheckedUpdateWithoutDialogInput>
  }

  export type MessageModelUpdateManyWithWhereWithoutDialogInput = {
    where: MessageModelScalarWhereInput
    data: XOR<MessageModelUpdateManyMutationInput, MessageModelUncheckedUpdateManyWithoutDialogInput>
  }

  export type MessageModelScalarWhereInput = {
    AND?: MessageModelScalarWhereInput | MessageModelScalarWhereInput[]
    OR?: MessageModelScalarWhereInput[]
    NOT?: MessageModelScalarWhereInput | MessageModelScalarWhereInput[]
    id?: IntFilter<"MessageModel"> | number
    createdAt?: DateTimeNullableFilter<"MessageModel"> | Date | string | null
    userId?: IntFilter<"MessageModel"> | number
    text?: StringFilter<"MessageModel"> | string
    dialogId?: IntFilter<"MessageModel"> | number
  }

  export type DialogModelCreateWithoutMessagesInput = {
    members: string
  }

  export type DialogModelUncheckedCreateWithoutMessagesInput = {
    id?: number
    members: string
  }

  export type DialogModelCreateOrConnectWithoutMessagesInput = {
    where: DialogModelWhereUniqueInput
    create: XOR<DialogModelCreateWithoutMessagesInput, DialogModelUncheckedCreateWithoutMessagesInput>
  }

  export type DialogModelUpsertWithoutMessagesInput = {
    update: XOR<DialogModelUpdateWithoutMessagesInput, DialogModelUncheckedUpdateWithoutMessagesInput>
    create: XOR<DialogModelCreateWithoutMessagesInput, DialogModelUncheckedCreateWithoutMessagesInput>
    where?: DialogModelWhereInput
  }

  export type DialogModelUpdateToOneWithWhereWithoutMessagesInput = {
    where?: DialogModelWhereInput
    data: XOR<DialogModelUpdateWithoutMessagesInput, DialogModelUncheckedUpdateWithoutMessagesInput>
  }

  export type DialogModelUpdateWithoutMessagesInput = {
    members?: StringFieldUpdateOperationsInput | string
  }

  export type DialogModelUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    members?: StringFieldUpdateOperationsInput | string
  }

  export type MessageModelUpdateWithoutDialogInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type MessageModelUncheckedUpdateWithoutDialogInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type MessageModelUncheckedUpdateManyWithoutDialogInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use DialogModelCountOutputTypeDefaultArgs instead
     */
    export type DialogModelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DialogModelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserModelDefaultArgs instead
     */
    export type UserModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserPasswordModelDefaultArgs instead
     */
    export type UserPasswordModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserPasswordModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileModelDefaultArgs instead
     */
    export type ProfileModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactsModelDefaultArgs instead
     */
    export type ContactsModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactsModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhotosModelDefaultArgs instead
     */
    export type PhotosModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhotosModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DialogModelDefaultArgs instead
     */
    export type DialogModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DialogModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageModelDefaultArgs instead
     */
    export type MessageModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageModelDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}